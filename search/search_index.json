{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 \u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Start"},{"location":"#home","text":"\u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Home"},{"location":"ATCF_default_source/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <bits/stdc++.h> #define int long long #define MAX 100010 #define INF 4557430888798830399 #define eb emplace_back #define fi first #define se second using namespace std ; const int mod = 998244353 ; inline void Madd ( int & a , int b ){ a = a + b >= mod ? a + b - mod : a + b ;} inline void Mdel ( int & a , int b ){ a = a - b < 0 ? a - b + mod : a - b ;} inline void Mmul ( int & a , int b ){ a = a * b % mod ;} inline int Cadd ( int a , int b ){ return a + b >= mod ? a + b - mod : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + mod : a - b ;} inline int Cmul ( int a , int b ){ return a * b % mod ;} int n , a [ MAX ], ans ; inline void solve () { } signed main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); int T = 1 ; //cin>>T; while ( T -- ) solve (); return ( 0-0 ); }","title":"AT/CF\u7f3a\u7701\u6e90"},{"location":"default_source/","text":"\u73af\u5883\u914d\u7f6e\uff1a -lm -Wall -Wl,--stack=536870912 -O2 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <bits/stdc++.h> #define ld long double #define ui unsigned int #define ull unsigned long long #define int long long #define eb emplace_back #define pb pop_back #define ins insert #define mp make_pair #define pii pair<int,int> #define fi first #define se second #define power(x) ((x)*(x)) #define gcd(x,y) (__gcd((x),(y))) #define lcm(x,y) ((x)*(y)/gcd((x),(y))) #define lg(x,y) (__lg((x),(y))) using namespace std ; namespace FastIO { template < typename T = int > inline T read () { T s = 0 , w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s * 10 ) + ( c ^ 48 ), c = getchar (); return s * w ; } template < typename T > inline void read ( T & s ) { s = 0 ; int w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s * 10 ) + ( c ^ 48 ), c = getchar (); s = s * w ; } template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ) { read ( x ), read ( args ...); } template < typename T > inline void write ( T x , char ch ) { if ( x < 0 ) x =- x , putchar ( '-' ); static char stk [ 25 ]; int top = 0 ; do { stk [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( stk [ -- top ]); putchar ( ch ); return ; } } using namespace FastIO ; namespace MTool { #define TA template<typename T,typename... Args> #define TT template<typename T> static const int Mod = 998244353 ; TT inline void Swp ( T & a , T & b ) { T t = a ; a = b ; b = t ;} TT inline void cmax ( T & a , T b ) { a = a > b ? a : b ;} TT inline void cmin ( T & a , T b ) { a = a < b ? a : b ;} TT inline void Madd ( T & a , T b ) { a = a + b > Mod ? a + b - Mod : a + b ;} TT inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} TT inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} TT inline void Mmod ( T a ) { a = ( a % Mod + Mod ) % Mod ;} TT inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} TT inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} TT inline T Cmul ( T a , T b ) { return a * b % Mod ;} TT inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} TA inline void Madd ( T & a , T b , Args ... args ) { Madd ( a , Cadd ( b , args ...));} TA inline void Mdel ( T & a , T b , Args ... args ) { Mdel ( a , Cadd ( b , args ...));} TA inline void Mmul ( T & a , T b , Args ... args ) { Mmul ( a , Cmul ( b , args ...));} TA inline T Cadd ( T a , T b , Args ... args ) { return Cadd ( Cadd ( a , b ), args ...);} TA inline T Cdel ( T a , T b , Args ... args ) { return Cdel ( Cdel ( a , b ), args ...);} TA inline T Cmul ( T a , T b , Args ... args ) { return Cmul ( Cmul ( a , b ), args ...);} TT inline T qpow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} TT inline T qmul ( T a , T b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} TT inline T spow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} TT inline void exgcd ( T A , T B , T & X , T & Y ) { if ( ! B ) return X = 1 , Y = 0 , void (); exgcd ( B , A % B , Y , X ), Y -= X * ( A / B );} TT inline T Ginv ( T x ) { T A = 0 , B = 0 ; exgcd ( x , Mod , A , B ); return Cmod ( A );} #undef TT #undef TA } using namespace MTool ; inline void file () { freopen ( \".in\" , \"r\" , stdin ); freopen ( \".out\" , \"w\" , stdout ); return ; } bool Mbe ; namespace LgxTpre { static const int MAX = 100010 ; static const int inf = 2147483647 ; static const int INF = 4557430888798830399 ; static const int mod = 1e9 + 7 ; static const int bas = 131 ; inline void mian () { return ; } } bool Med ; signed main () { // file(); fprintf ( stderr , \"%.3lf MB \\n \" , abs ( & Med -& Mbe ) / 1048576.0 ); int Tbe = clock (); LgxTpre :: mian (); int Ted = clock (); cerr << 1e3 * ( Ted - Tbe ) / CLOCKS_PER_SEC << \" ms \\n \" ; return ( 0-0 ); }","title":"\u5e38\u7528\u7f3a\u7701\u6e90"},{"location":"ds/BST/","text":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } } \u6587\u827a\u5e73\u8861\u6811 FHQ_Treap\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( lson [ i ], rson [ i ]), tag [ lson [ i ]] ^= 1 , tag [ rson [ i ]] ^= 1 , tag [ i ] = 0 ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( lson [ siz [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); tag [ mid ] ^= 1 ; root = merge ( merge ( l , mid ), r ); } }","title":"\u5e73\u8861\u6811"},{"location":"ds/BST/#fhq_treap","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } }","title":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap\uff1a"},{"location":"ds/BST/#fhq_treap_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( lson [ i ], rson [ i ]), tag [ lson [ i ]] ^= 1 , tag [ rson [ i ]] ^= 1 , tag [ i ] = 0 ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( lson [ siz [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); tag [ mid ] ^= 1 ; root = merge ( merge ( l , mid ), r ); } }","title":"\u6587\u827a\u5e73\u8861\u6811 FHQ_Treap\uff1a"},{"location":"ds/DSU/","text":"\u666e\u901a\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( y ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } \u53ef\u64a4\u9500\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace RDSU { int N ; int fa [ MAX ], siz [ MAX ]; struct dsu { int x , fx , siz ; dsu ( int X = 0 , int Fx = 0 , int Siz = 0 ) { x = X , fx = Fx , siz = Siz ;} } stk [ MAX ]; int top ; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} inline int find ( int x ) { while ( x != fa [ x ]) x = fa [ x ]; return x ;} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); stk [ ++ top ] = dsu ( x , fa [ x ], siz [ x ]), stk [ ++ top ] = dsu ( y , fa [ y ], siz [ y ]); siz [ x ] += siz [ y ], fa [ y ] = x ; } inline void back ( int last ) { while ( top > last ) fa [ stk [ top ]. x ] = stk [ top ]. fx , siz [ stk [ top ]. x ] = stk [ top ]. siz , -- top ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u5e76\u67e5\u96c6"},{"location":"ds/LCT/","text":"\u901a\u7528\u6a21\u677f\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"LCT"},{"location":"ds/LCT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"\u901a\u7528\u6a21\u677f\uff1a"},{"location":"graph/MST/","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/flow/","text":"\u6700\u5927\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } } \u8d39\u7528\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u7f51\u7edc\u6d41"},{"location":"graph/flow/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } }","title":"\u6700\u5927\u6d41\uff1a"},{"location":"graph/flow/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u8d39\u7528\u6d41\uff1a"},{"location":"graph/shortpath/","text":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } } SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } } SPFA \u5224\u8d1f\u73af\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } } Johnson\u5168\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"\u6700\u77ed\u8def\u76f8\u5173"},{"location":"graph/shortpath/#dijktra","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } }","title":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } }","title":"SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } }","title":"SPFA \u5224\u8d1f\u73af\uff1a"},{"location":"graph/shortpath/#johnson","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"Johnson\u5168\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/tarjan/","text":"","title":"tarjan"},{"location":"math/Pollard_Rho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 namespace Prime_Check { int mix , seed , step ; static const int P [] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }; static const int Pcnt = 12 ; inline int qmul ( int a , int b , int mod ) { int ans = a * b - ( int )(( long double ) a * b / mod + 0.5 ) * mod ; return ans < 0 ? ans + mod : ans ;} inline int qpow ( int a , int b , int mod ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a , mod ); a = qmul ( a , a , mod ); b >>= 1 ;} return res ;} inline int f ( int x , int mod ) { return ( qmul ( x , x , mod ) + seed ) % mod ;} inline int randoom ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline bool Miller_Robin ( int x ) { if ( x <= 2 ) return x == 2 ; int y_ = x -1 ; while ( ! ( y_ & 1 )) y_ >>= 1 ; for ( int i = 0 ; i < Pcnt ; ++ i ) { if ( x == P [ i ]) return 1 ; int flag = 0 , y = y_ , z = qpow ( P [ i ], y , x ); if ( z == 1 ) flag = 1 ; else while ( y < x -1 ) { if ( z == x -1 ) { flag = 1 ; break ;} y <<= 1 , z = qmul ( z , z , x ); } if ( ! flag ) return 0 ; } return 1 ; } inline int floyd ( int x ) { seed = randoom ( 0 , x -1 ); int fast , slow , res = 1 ; fast = slow = randoom ( 0 , x -1 ); fast = f ( fast , x ); for ( int i = 0 ; slow != fast ; ++ i ) { res = qmul ( res ,( fast - slow ) % x + x , x ); if ( ! res ) res = ( fast - slow ) % x + x ; if ( i % step == 0 ) { int g = gcd ( res , x ); if ( g != 1 ) return g ; res = 1 ;} slow = f ( slow , x ), fast = f ( f ( fast , x ), x ); } return gcd ( res , x ); } inline void Pollard_Rho ( int x ) { if ( x == 1 ) return ; if ( Miller_Robin ( x )) return cmax ( mix , x ); int k = 1 ; step = (( int ) log ( x )) << 1 | 1 ; while ( k == 1 ) k = floyd ( x ); Pollard_Rho ( k ), Pollard_Rho ( x / k ); } inline int solve ( int n ) { mix = 0 ; Pollard_Rho ( n ); if ( mix == n ) return -1 ; else return mix ; } }","title":"Pollard_Rho"},{"location":"math/Sieve/","text":"\u7ebf\u6027\u7b5b\u7d20\u6570\u3002 \u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570\uff1a \\(d_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570\uff0c \\(num_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u51fa\u73b0\u6b21\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c\uff1a \\(f_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c\uff0c \\(g_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 namespace Sieve { static const int N = 100000 ; static const int MAX = 10010 ; int vis [ N + 10 ], P [ MAX ], Pcnt ; inline void Linear_Sieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( ! i % P [ j ]) break ; } } return ; } int phi [ N + 10 ]; inline void Phi_Sieve () { phi [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , phi [ i ] = i -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) phi [ i * P [ j ]] = phi [ i ] * phi [ P [ j ]]; else { phi [ i * P [ j ]] = phi [ i ] * P [ j ]; break ;} } } return ; } int mu [ N + 10 ]; inline void Mu_Sieve () { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , mu [ i ] = -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) mu [ i * P [ j ]] =- mu [ i ]; else { mu [ i * P [ j ]] = 0 ; break ;} } } return ; } int d [ N + 10 ], num [ N + 10 ]; inline void D_Sieve () { d [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , d [ i ] = 2 , num [ i ] = 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) num [ i * P [ j ]] = 1 , d [ i * P [ j ]] = d [ i ] * 2 ; else { num [ i * P [ j ]] = num [ i ] + 1 , d [ i * P [ j ]] = d [ i ] / num [ i * P [ j ]] * ( num [ i * P [ j ]] + 1 ); break ;} } } return ; } int f [ N + 10 ], g [ N + 10 ]; inline void Sum_Sieve () { f [ 1 ] = g [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , f [ i ] = g [ i ] = i + 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) f [ i * P [ j ]] = f [ i ] * f [ P [ j ]], g [ i * P [ j ]] = P [ j ] + 1 ; else { f [ i * P [ j ]] = f [ i ] / g [ i ] * ( g [ i ] * P [ j ] + 1 ), g [ i * P [ j ]] = g [ i ] * P [ j ] + 1 ; break ;} } } return ; } }","title":"\u7b5b\u6cd5"},{"location":"package/BigNum/","text":"","title":"BigNum"},{"location":"package/Geometry/","text":"","title":"Geometry"},{"location":"package/ModNum/","text":"\u53ef\u53d8\u6a21\u6570\u5feb\u901f\u53d6\u6a21\uff0c\u66f4\u6539\u6a21\u6570\u8c03\u7528 ChangeMod \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 struct ModNum { #define TA template<typename T,typename... Args> #define TT template<typename T> struct fastmod { using u128 = __uint128_t ; using u64 = uint64_t ; using u32 = signed ; u32 f , l ; u64 m , d ; fastmod ( u64 D = 998244353 ) : d ( D ) { const u128 ONE = 1 ; l = 64 - __builtin_clzll ( d -1 ); u128 M = (( ONE << ( 64 + l )) + ( ONE << l )) / d ; if ( M < ( ONE << 64 )) f = 1 , m = M ; else f = 0 , m = M - ( ONE << 64 ); } inline friend u64 operator / ( u64 x , const fastmod & y ) { if ( y . f ) return u128 ( x ) * y . m >> 64 >> y . l ; else return ((( x - ( u128 ( x ) * y . m >> 64 )) >> 1 ) + ( u128 ( x ) * y . m >> 64 )) >> ( y . l -1 ); } inline friend u64 operator % ( u64 x , const fastmod & y ) { return x - x / y * y . d ; } inline friend u64 operator + ( u64 x , const fastmod & y ) { return x + y . d ;} inline friend u64 operator - ( u64 x , const fastmod & y ) { return x - y . d ;} inline friend bool operator == ( u64 x , const fastmod & y ) { return x == y . d ;} inline friend bool operator > ( u64 x , const fastmod & y ) { return x > y . d ;} inline friend bool operator < ( u64 x , const fastmod & y ) { return x < y . d ;} inline friend bool operator >= ( u64 x , const fastmod & y ) { return x > y . d || x == y . d ;} inline friend bool operator <= ( u64 x , const fastmod & y ) { return x < y . d || x == y . d ;} }; fastmod Mod ; inline void ChangeMod ( int MOD ){ Mod = MOD ;} TT inline void Madd ( T & a , T b ) { a = a + b > Mod ? a + b - Mod : a + b ;} TT inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} TT inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} TT inline void Mmod ( T a ) { a = ( a % Mod + Mod ) % Mod ;} TT inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} TT inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} TT inline T Cmul ( T a , T b ) { return a * b % Mod ;} TT inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} TA inline void Madd ( T & a , T b , Args ... args ) { Madd ( a , Cadd ( b , args ...));} TA inline void Mdel ( T & a , T b , Args ... args ) { Mdel ( a , Cadd ( b , args ...));} TA inline void Mmul ( T & a , T b , Args ... args ) { Mmul ( a , Cmul ( b , args ...));} TA inline T Cadd ( T a , T b , Args ... args ) { return Cadd ( Cadd ( a , b ), args ...);} TA inline T Cdel ( T a , T b , Args ... args ) { return Cdel ( Cdel ( a , b ), args ...);} TA inline T Cmul ( T a , T b , Args ... args ) { return Cmul ( Cmul ( a , b ), args ...);} TT inline T qpow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} TT inline T qmul ( T a , T b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} TT inline T spow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} TT inline T Ginv ( T x ) { return qpow ( x ,( T )( Mod . d -2 ));} #undef TT #undef TA };","title":"ModNum"},{"location":"package/Poly/","text":"\u4f7f\u7528\u6ce8\u610f\u4e8b\u9879\uff1a \u8981\u5148\u8fd0\u884c Prework \uff0c\u53c2\u6570\u662f\u591a\u9879\u5f0f\u6700\u9ad8\u5ea6\u6570\uff0c\u6709\u65f6\u5019\u7b54\u6848\u4e0d\u5bf9\u53ef\u80fd\u662f\u521d\u59cb\u5316\u5c0f\u4e86\uff0c\u5f00\u5927\u70b9\u8bd5\u8bd5\u3002 NTT \u7684\u6a21\u6570\u4e0d\u540c\u9700\u8981\u66f4\u6539 Prework \u7684\u53c2\u6570\uff0c\u82e5\u6a21\u6570\u4e3a \\(r \\times 2^k + 1\\) \uff0c\u90a3\u4e48 \\(GT\\) \u6539\u4e3a \\(k - 2\\) \uff0c \\(GR\\) \u6539\u4e3a \\(g^r\\) \uff0c\u5176\u4e2d \\(g\\) \u4e3a\u6a21\u6570\u7684\u539f\u6839\u3002 \u8d4b\u503c\u7528 .pin \uff0c\u8f93\u51fa\u7528 .pout \u3002 \u591a\u9879\u5f0f\u5c01\u88c5\u4e86\u4e00\u4e2a poly \u7c7b\uff0c\u91cc\u5934\u662f\u81ea\u53d6\u6a21\u7684 ModInt \u7c7b\uff0c\u6a21\u6570\u4e0d\u540c\u9700\u8981\u4fee\u6539 Mod \u3002 \u5404\u51fd\u6570\u610f\u4e49\uff1a \u4e58\u6cd5\u76f4\u63a5\u7528 * \uff1b\u9664\u6cd5\u5982\u679c\u540c\u65f6\u6c42\u5546\u548c\u4f59\u6570\u7528 Div \uff0c\u8fd4\u56de\u4e00\u4e2a poly \u4e8c\u5143\u7ec4\uff0c\u5426\u5219\u76f4\u63a5\u7528 / \u6216\u8005 % \u5373\u53ef\u3002 Inv \u4e3a\u6c42\u9006\uff0c Dvt \u4e3a\u6c42\u5bfc\uff0c Igt \u4e3a\u79ef\u5206\u3002 Ln \u4e3a\u6c42\u5bf9\u6570\uff0c Exp \u4e3a\u6c42\u6307\u6570\u3002 Sqr \u4e3a\u5f00\u65b9\uff0c\u4f20\u53c2 \\(tp = 1\\) \u8fd4\u56de \\(\\sqrt{a}\\) \uff0c \\(tp = -1\\) \u8fd4\u56de \\(\\dfrac{1}{\\sqrt{a}}\\) \u3002 Pow \u4e3a\u5feb\u901f\u5e42\uff0c\u7b2c\u4e00\u4e2a\u975e \\(0\\) \u9879\u4e3a\u5e38\u6570\uff0c\u4f20\u5e42\u6b21\u76f4\u63a5\u4f20\u6570\u503c\uff0c\u5426\u5219\u4f20\u8fdb\u53bb\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002 \u4e09\u89d2\u51fd\u6570\u548c\u53cd\u4e09\u89d2\u51fd\u6570\u540c\u51fd\u6570\u540d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 namespace Poly { template < const int Mod > struct ModInt { int x ; ModInt ( int X = 0 ) : x ( X ) {} inline ModInt operator = ( int & T ) { * this . x = T ; return * this ;} inline ModInt operator = ( const ModInt & T ) { this -> x = T . x ; return * this ;} inline friend ModInt operator + ( ModInt a , ModInt b ) { return a . x + b . x >= Mod ? a . x + b . x - Mod : a . x + b . x ;} inline friend ModInt operator - ( ModInt a , ModInt b ) { return a . x - b . x < 0 ? a . x - b . x + Mod : a . x - b . x ;} inline friend ModInt operator * ( ModInt a , ModInt b ) { return a . x * b . x % Mod ;} inline friend ModInt operator ^ ( ModInt a , int b ) { ModInt res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ;} inline friend ModInt operator / ( ModInt a , ModInt b ) { return a * ( b ^ ( Mod -2 ));} inline ModInt operator += ( const ModInt & T ) { * this =* this + T ; return * this ;} inline ModInt operator -= ( const ModInt & T ) { * this =* this - T ; return * this ;} inline ModInt operator *= ( const ModInt & T ) { * this =* this * T ; return * this ;} inline ModInt operator ^= ( const ModInt & T ) { * this =* this ^ T ; return * this ;} inline ModInt operator /= ( const ModInt & T ) { * this =* this / T ; return * this ;} template < typename T > inline friend ModInt operator + ( ModInt a , T x ) { return a + ModInt ( x );} template < typename T > inline friend ModInt operator - ( ModInt a , T x ) { return a - ModInt ( x );} template < typename T > inline friend ModInt operator * ( ModInt a , T x ) { return a * ModInt ( x );} template < typename T > inline friend ModInt operator / ( ModInt a , T x ) { return a / ModInt ( x );} inline friend bool operator == ( ModInt a , ModInt b ) { return a . x == b . x ;} inline friend bool operator != ( ModInt a , ModInt b ) { return a . x != b . x ;} inline friend bool operator > ( ModInt a , ModInt b ) { return a . x > b . x ;} inline friend bool operator < ( ModInt a , ModInt b ) { return a . x < b . x ;} inline friend bool operator >= ( ModInt a , ModInt b ) { return a > b || a == b ;} inline friend bool operator <= ( ModInt a , ModInt b ) { return a < b || a == b ;} template < typename T > inline friend bool operator == ( ModInt a , T b ) { return a == ModInt ( b );} template < typename T > inline friend bool operator != ( ModInt a , T b ) { return a != ModInt ( b );} template < typename T > inline friend bool operator > ( ModInt a , T b ) { return a > ModInt ( b );} template < typename T > inline friend bool operator < ( ModInt a , T b ) { return a < ModInt ( b );} template < typename T > inline friend bool operator >= ( ModInt a , T b ) { return a >= ModInt ( b );} template < typename T > inline friend bool operator <= ( ModInt a , T b ) { return a <= ModInt ( b );} inline bool operator ! () { return ! x ;} inline ModInt operator - () { return x ? Mod - x : 0 ;} }; static const int Mod = 998244353 ; static const int MAX = 4000010 ; static const double PI = acos ( -1 ); static const ModInt < Mod > gn = 332748118 , gni = 3 , ZERO = 0 , ONE = 1 ; namespace Quadraticresidue { ModInt < Mod > I ; struct Complex { ModInt < Mod > x , y ; Complex ( ModInt < Mod > X = 0 , ModInt < Mod > Y = 0 ) : x ( X ), y ( Y ) {} inline friend bool operator == ( Complex a , Complex b ) { return a . x == b . x && a . y == b . y ;} inline friend Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x + a . y * b . y * I , a . x * b . y + a . y * b . x );} }; inline Complex qpow ( Complex a , int b ) { Complex res ( 1 , 0 ); while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ;} inline ModInt < Mod > random ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return ModInt < Mod > ( range ( sd )); } inline pair < ModInt < Mod > , ModInt < Mod >> Cipolla ( ModInt < Mod > n ) { if ( ! n ) return make_pair ( 0 , 0 ); ModInt < Mod > x , x1 , x2 ; do x = random ( 1 , Mod -1 ); while ((( x * x + Mod - n ) ^ (( Mod -1 ) >> 1 )) == ONE ); I = x * x + Mod - n , x1 = qpow ( Complex ( x , 1 ),( Mod + 1 ) >> 1 ). x , x2 = Mod - x1 ; return make_pair ( min ( x1 , x2 ), max ( x1 , x2 )); } } using namespace Quadraticresidue ; struct poly { vector < ModInt < Mod >> a ; inline ModInt < Mod > & operator [] ( int i ) { return a [ i ];} inline poly operator = ( const poly & T ) { this -> a = T . a ; return * this ;} inline int size () { return a . size ();} inline void resize ( int N ) { return a . resize ( N ), void ();} inline void reverse () { return std :: reverse ( a . begin (), a . end ());} inline void pin ( int x ) { return a . emplace_back ( ModInt < Mod > ( x )), void ();} inline void pout () { for ( auto it : a ) write ( it . x , ' ' );} }; inline int Sup ( int N ) { int K = 1 ; while ( K < N ) K <<= 1 ; return K ;} static const int GT = 21 , GR = 31 ; ModInt < Mod > omega [ MAX ]; poly zero , one ; inline void Prework ( int N ) { zero . a . emplace_back ( ZERO ), one . a . emplace_back ( ONE ); int K = 1 ; while (( 1 << K ) < N ) ++ K ; K = min ( K -1 , 21l l ); omega [ 0 ] = 1 , omega [ 1 << K ] = ( ModInt < Mod > ( GR )) ^ ( 1 << ( GT - K )); for ( int i = K ; i >= 1 ; -- i ) omega [ 1 << ( i -1 )] = omega [ 1 << i ] * omega [ 1 << i ]; for ( int i = 1 ; i < ( 1 << K ); ++ i ) omega [ i ] = omega [ i & ( i -1 )] * omega [ i & ( - i )]; } inline void NTT ( poly & F , int typ ) { ModInt < Mod > U , V ; int N = F . size (); if ( typ == 1 ) { for ( int mid = N >> 1 ; mid >= 1 ; mid >>= 1 ) for ( int i = 0 , k = 0 ; i < N ; i += mid << 1 , ++ k ) for ( int j = 0 ; j < mid ; ++ j ) U = F [ i + j ], V = F [ i + j + mid ] * omega [ k ], F [ i + j ] = U + V , F [ i + j + mid ] = U - V ; } if ( typ == -1 ) { for ( int mid = 1 ; mid < N ; mid <<= 1 ) for ( int i = 0 , k = 0 ; i < N ; i += mid << 1 , ++ k ) for ( int j = 0 ; j < mid ; ++ j ) U = F [ i + j ], V = F [ i + j + mid ], F [ i + j ] = U + V , F [ i + j + mid ] = ( U - V ) * omega [ k ]; ModInt < Mod > Ninv = ONE / N ; for ( int i = 0 ; i < N ; ++ i ) F [ i ] *= Ninv ; reverse ( F . a . begin () + 1 , F . a . end ()); } } inline poly operator * ( poly a , ModInt < Mod > b ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] *= b ; return a ;} inline poly operator / ( poly a , ModInt < Mod > b ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] /= b ; return a ;} inline poly operator - ( poly a ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] =- a [ i ]; return a ;} inline poly operator + ( poly a , poly b ) { int N = max ( a . size (), b . size ()); a . resize ( N ), b . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] += b [ i ]; return a ; } inline poly operator - ( poly a , poly b ) { int N = max ( a . size (), b . size ()); a . resize ( N ), b . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] -= b [ i ]; return a ; } inline poly operator * ( poly a , poly b ) { int K = a . size () + b . size () -1 , N = Sup ( K ); a . resize ( N ), b . resize ( N ); NTT ( a , 1 ), NTT ( b , 1 ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] *= b [ i ]; NTT ( a , -1 ); a . resize ( K ); return a ; } inline poly operator >> ( poly a , int d ) { int N = a . size (); poly b ; b . resize ( N + d ); for ( int i = 0 ; i < N ; ++ i ) b [ i + d ] = a [ i ]; return b ; } inline poly operator << ( poly a , int d ) { int N = a . size (); if ( N <= d ) return zero ; poly b ; b . resize ( N - d ); for ( int i = 0 ; i < N - d ; ++ i ) b [ i ] = a [ i + d ]; return b ; } inline poly Dvt ( poly a ) { int N = a . size () -1 ; for ( int i = 0 ; i < N ; ++ i ) a [ i ] = a [ i + 1 ] * ( i + 1 ); return a . resize ( N ), a ; } inline poly Itg ( poly a ) { int N = a . size () + 1 ; a . resize ( N ); for ( int i = N ; i >= 1 ; -- i ) a [ i ] = a [ i -1 ] / i ; return a [ 0 ] = 0 , a ; } inline poly Inv ( poly a ) { int K = a . size (), N = Sup ( K ); poly b , c , d ; a . resize ( N ), b . resize ( N ); b [ 0 ] = ONE / a [ 0 ]; for ( int len = 2 ; len <= N ; len <<= 1 ) { c . resize ( len ), d . resize ( len ); for ( int i = 0 ; i < len ; ++ i ) c [ i ] = a [ i ]; for ( int i = 0 ; i < ( len >> 1 ); ++ i ) d [ i ] = b [ i ]; NTT ( c , 1 ), NTT ( d , 1 ); for ( int i = 0 ; i < len ; ++ i ) c [ i ] = c [ i ] * d [ i ]; NTT ( c , -1 ); for ( int i = 1 ; i < ( len >> 1 ); ++ i ) c [ i ] = 0 ; c [ 0 ] = Mod -1 ; NTT ( c , 1 ); for ( int i = 0 ; i < len ; ++ i ) d [ i ] = d [ i ] * c [ i ]; NTT ( d , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) b [ i ] =- d [ i ]; } b . resize ( K ); return b ; } inline poly operator / ( poly a , poly b ) { int N = a . size (), M = b . size (); poly c = a , d = b ; c . reverse (), d . reverse (); d . resize ( N - M + 1 ), d = Inv ( d ); c = c * d ; c . resize ( N - M + 1 ), c . reverse (); return c ; } inline poly operator % ( poly a , poly b ) { int M = b . size (); poly q = a / b ; b = b * q ; poly r = a - b ; r . resize ( M -1 ); return r ; } inline pair < poly , poly > Div ( poly a , poly b ) { int M = b . size (); poly q = a / b ; b = b * q ; poly r = a - b ; r . resize ( M -1 ); return make_pair ( q , r ); } namespace DivideConquer { poly F [ 20 ][ 8 ], G [ 20 ][ 8 ]; inline void brute ( poly & a , poly & b , int l , int r , void work ( poly & a , poly & b , int i )) { work ( a , b , l ); for ( int i = l + 1 ; i <= r ; ++ i ) { for ( int j = l ; j < i ; ++ j ) a [ i ] += a [ j ] * b [ i - j ]; work ( a , b , i ); } } inline void Divide ( poly & a , poly & b , int l , int r , int dep , void work ( poly & a , poly & b , int i )) { if ( r - l + 1 <= 32 ) return brute ( a , b , l , r , work ); if ( l >= r ) return ; int coef = 1 << (( dep -1 ) * 3 ); poly tmp ; tmp . resize ( coef << 1 ); for ( int i = 0 ;; ++ i ) { int L = l + i * coef , R = min ( r , L + coef -1 ); if ( i ) { for ( int j = 0 ; j < ( coef << 1 ); ++ j ) tmp [ j ] = 0 ; for ( int j = 0 ; j < i ; ++ j ) for ( int k = 0 ; k < ( coef << 1 ); ++ k ) tmp [ k ] += F [ dep ][ j ][ k ] * G [ dep ][ i - j ][ k ]; NTT ( tmp , -1 ); for ( int j = L ; j <= R ; ++ j ) a [ j ] += tmp [ j - L + coef ]; } Divide ( a , b , L , R , dep -1 , work ); if ( R == r ) return ; for ( int j = 0 ; j < ( coef << 1 ); ++ j ) F [ dep ][ i ][ j ] = 0 ; for ( int j = L ; j <= R ; ++ j ) F [ dep ][ i ][ j - L ] = a [ j ]; NTT ( F [ dep ][ i ], 1 ); } } inline void solve ( poly & a , poly & b , int N , void work ( poly & a , poly & b , int i )) { if ( N <= 128 ) return brute ( a , b , 0 , N -1 , work ); int len = 1 , dep = 0 ; while ( len < N ) len <<= 3 , ++ dep ; len >>= 3 ; for ( int i = 1 ; i <= dep ; ++ i ) { int coef = 1 << (( i -1 ) * 3 ), mix = min (( N -1 ) / coef , 7l l ); for ( int j = 1 ; j <= mix ; ++ j ) { int L = ( j -1 ) * coef + 1 , R = min ( N -1 ,( j + 1 ) * coef -1 ); F [ i ][ j -1 ]. resize ( coef << 1 ), G [ i ][ j ]. resize ( coef << 1 ); for ( int k = 0 ; k < ( coef << 1 ); ++ k ) G [ i ][ j ][ k ] = 0 ; for ( int k = L ; k <= R ; ++ k ) G [ i ][ j ][ k - L + 1 ] = b [ k ]; NTT ( G [ i ][ j ], 1 ); } } Divide ( a , b , 0 , N -1 , dep , work ); } } using namespace DivideConquer ; inline void workln ( poly & a , poly & b , int i ) { if ( ! i ) a [ i ] = 0 ; else a [ i ] = i * b [ i ] - a [ i ]; } inline poly Ln ( poly a ) { int N = a . size (); poly b ; b . resize ( N ); solve ( b , a , N , workln ); b [ 0 ] = 0 ; for ( int i = 1 ; i < N ; ++ i ) b [ i ] *= ONE / i ; return b ; } inline void workexp ( poly & a , poly & b , int i ) { if ( ! i ) a [ i ] = 1 ; else a [ i ] *= ONE / i ; } inline poly Exp ( poly a ) { int N = a . size (); for ( int i = 0 ; i < N ; ++ i ) a [ i ] = a [ i ] * i ; poly b ; b . resize ( N ); solve ( b , a , N , workexp ); return b ; } inline void PrePow ( char * s , int & k1 , int & k2 , int & k3 ) { int len = strlen ( s + 1 ); for ( int i = 1 ; i <= len ; ++ i ) k1 = (( k1 * 10 ) + ( s [ i ] ^ 48 )) % Mod , k2 = (( k2 * 10 ) + ( s [ i ] ^ 48 )) % ( Mod -1 ); for ( int i = 1 ; i <= min ( 7l l , len ); ++ i ) k3 = ( k3 * 10 ) + ( s [ i ] ^ 48 ); } inline poly Pow ( poly a , ModInt < Mod > b ) { int N = a . size (); a = Exp ( Ln ( a ) * b ), a . resize ( N ); return a ; } inline poly Pow ( poly a , char * s ) { int N = a . size (), lst = N ; ModInt < Mod > k1 , k2 , k3 ; PrePow ( s , k1 . x , k2 . x , k3 . x ); poly b ; b . resize ( N ); if ( a [ 0 ] == 0 && k3 >= N ) return b ; for ( int i = 0 ; i < N ; ++ i ) if ( a [ i ] != 0 ) { lst = i ; break ;} if ( lst * k1 >= N ) return b ; ModInt < Mod > inv = ONE / a [ lst ], p = a [ lst ] ^ ( k2 . x ); for ( int i = 0 ; i < N - lst ; ++ i ) a [ i ] = a [ i + lst ] * inv ; for ( int i = N - lst ; i < N ; ++ i ) a [ i ] = 0 ; a = Ln ( a ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] *= k1 ; a = Exp ( a ), lst = lst * k1 . x ; for ( int i = N -1 ; i >= lst ; -- i ) b [ i ] = a [ i - lst ] * p ; return b ; } inline poly Sqr ( poly a , int typ ) { int K = a . size (), N = Sup ( K ); poly f , g , h , tmp , res , ans ; f . resize ( N ), g . resize ( N ), h . resize ( N ), res . resize ( 1 ); f [ 0 ] = g [ 0 ] = Cipolla ( a [ 0 ]). first , h [ 0 ] = ONE / g [ 0 ]; for ( int len = 2 ; len <= N ; len <<= 1 ) { tmp . resize ( len ), ans . resize ( len ); for ( int i = 0 ; i < ( len >> 1 ); ++ i ) tmp [ i ] = h [ i ], res [ i ] = g [ i ] * g [ i ]; NTT ( res , -1 ); for ( int i = 0 ; i < ( len >> 1 ); ++ i ) ans [ i + ( len >> 1 )] = res [ i ] - a [ i ] - a [ i + ( len >> 1 )], ans [ i ] = 0 ; NTT ( ans , 1 ), NTT ( tmp , 1 ); for ( int i = 0 ; i < len ; ++ i ) ans [ i ] *= tmp [ i ] * ( ONE / 2 ); NTT ( ans , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) f [ i ] =- ans [ i ]; if ( len != N || typ == -1 ) { res . resize ( len ); for ( int i = 0 ; i < len ; ++ i ) res [ i ] = f [ i ]; NTT ( res , 1 ); for ( int i = 0 ; i < len ; ++ i ) g [ i ] = res [ i ], res [ i ] *= tmp [ i ]; NTT ( res , -1 ); res [ 0 ] = Mod -1 ; for ( int i = 1 ; i < ( len >> 1 ); ++ i ) res [ i ] = 0 ; NTT ( res , 1 ); for ( int i = 0 ; i < len ; ++ i ) res [ i ] *= tmp [ i ]; NTT ( res , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) h [ i ] =- res [ i ]; } } f . resize ( K ), h . resize ( K ); if ( typ == 1 ) return f ; else return h ; } inline poly sin ( poly a ) { ModInt < Mod > E = (( ModInt < Mod > ( 3 )) ^ (( Mod -1 ) >> 2 )); return ( Exp ( a * E ) - Exp ( a * ( - E ))) * (( E * 2 ) ^ ( Mod -2 )); } inline poly cos ( poly a ) { ModInt < Mod > E = (( ModInt < Mod > ( 3 )) ^ (( Mod -1 ) >> 2 )); return ( Exp ( a * E ) + Exp ( a * ( - E ))) * (( Mod + 1 ) >> 1 ); } inline poly tan ( poly a ) { int N = a . size (); a = sin ( a ) * Inv ( cos ( a )), a . resize ( N ); return a ; } inline poly arcsin ( poly a ) { int N = a . size (); poly b = a * a ; b . resize ( N ), b =- b , b [ 0 ] += 1 ; a = Itg ( Dvt ( a ) * Sqr ( b , -1 )); a . resize ( N ); return a ; } inline poly arctan ( poly a ) { int N = a . size (); poly b = a * a ; b . resize ( N ), b [ 0 ] += 1 ; a = Itg ( Dvt ( a ) * Inv ( b )); a . resize ( N ); return a ; } } using namespace Poly ;","title":"Poly"},{"location":"tree/CUT/","text":"\u91cd\u94fe\u5256\u5206\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace HPD { int fa [ MAX ], siz [ MAX ], son [ MAX ], dep [ MAX ], dfn [ MAX ], rid [ MAX ], tot ; void dfs1 ( int now , int father , int depth ) { fa [ now ] = father , dep [ now ] = depth , siz [ now ] = 1 ; for ( auto to : G [ now ]) if ( to != father ) { dfs1 ( to , now , depth + 1 ); siz [ now ] += siz [ to ]; if ( siz [ to ] > siz [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( int now , int topf ) { top [ now ] = topf , dnf [ now ] =++ tot , rid [ tot ] = now ; if ( ! son [ now ]) return ; dfs2 ( son [ now ], topf ); for ( auto to : G [ now ]) if ( to != fa [ now ] && to != son [ now ]) dfs2 ( to , to ); } inline int LCA ( int a , int b ) { while ( top [ a ] != top [ b ]) { if ( dep [ top [ a ]] < dep [ top [ b ]]) swap ( a , b ); a = fa [ top [ a ]]; } return dep [ a ] < dep [ b ] ? a : b ; } }","title":"\u6811\u94fe\u5256\u5206"},{"location":"tree/CUT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace HPD { int fa [ MAX ], siz [ MAX ], son [ MAX ], dep [ MAX ], dfn [ MAX ], rid [ MAX ], tot ; void dfs1 ( int now , int father , int depth ) { fa [ now ] = father , dep [ now ] = depth , siz [ now ] = 1 ; for ( auto to : G [ now ]) if ( to != father ) { dfs1 ( to , now , depth + 1 ); siz [ now ] += siz [ to ]; if ( siz [ to ] > siz [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( int now , int topf ) { top [ now ] = topf , dnf [ now ] =++ tot , rid [ tot ] = now ; if ( ! son [ now ]) return ; dfs2 ( son [ now ], topf ); for ( auto to : G [ now ]) if ( to != fa [ now ] && to != son [ now ]) dfs2 ( to , to ); } inline int LCA ( int a , int b ) { while ( top [ a ] != top [ b ]) { if ( dep [ top [ a ]] < dep [ top [ b ]]) swap ( a , b ); a = fa [ top [ a ]]; } return dep [ a ] < dep [ b ] ? a : b ; } }","title":"\u91cd\u94fe\u5256\u5206\uff1a"}]}