{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 \u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Start"},{"location":"#home","text":"\u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Home"},{"location":"ATCF_default_source/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bits/stdc++.h> #define int long long #define MAX 100010 #define INF 4557430888798830399 #define eb emplace_back #define fi first #define se second using namespace std ; int mod ; inline void Madd ( int & a , int b ){ a = a + b >= mod ? a + b - mod : a + b ;} inline void Mdel ( int & a , int b ){ a = a - b < 0 ? a - b + mod : a - b ;} inline void Mmul ( int & a , int b ){ a = a * b % mod ;} inline int Cadd ( int a , int b ){ return a + b >= mod ? a + b - mod : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + mod : a - b ;} inline int Cmul ( int a , int b ){ return a * b % mod ;} signed main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); return ( 0-0 ); }","title":"AT/CF\u7f3a\u7701\u6e90"},{"location":"default_source/","text":"\u73af\u5883\u914d\u7f6e\uff1a -lm -Wall -Wl,--stack=536870912 -O2 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include <bits/stdc++.h> #define ld long double #define ui unsigned int #define ull unsigned long long #define int long long #define eb emplace_back #define pb pop_back #define mp make_pair #define fi first #define se second #define pii pair<int,int> using namespace std ; template < typename T = int > inline T read () { T s = 0 , w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s << 1 ) + ( s << 3 ) + ( c ^ 48 ), c = getchar (); return s * w ; } template < typename T = int > inline void write ( T x , char ch ) { if ( x < 0 ) x =- x , putchar ( '-' ); static char stk [ 25 ]; int top = 0 ; do { stk [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( stk [ -- top ]); putchar ( ch ); return ; } namespace MyTool { static const int Mod = 998244353 ; template < typename T > inline void Swp ( T & a , T & b ) { T t = a ; a = b ; b = t ;} template < typename T > inline void cmax ( T & a , T b ) { a = a > b ? a : b ;} template < typename T > inline void cmin ( T & a , T b ) { a = a < b ? a : b ;} inline void Madd ( int & a , int b ) { a = a + b > Mod ? a + b - Mod : a + b ;} inline void Mdel ( int & a , int b ) { a = a - b < 0 ? a - b + Mod : a - b ;} inline void Mmul ( int & a , int b ) { a = 1l l * a * b % Mod ;} inline void Mmod ( int & a ) { a = ( a % Mod + Mod ) % Mod ;} inline int Cadd ( int a , int b ) { return a + b >= Mod ? a + b - Mod : a + b ;} inline int Cdel ( int a , int b ) { return a - b < 0 ? a - b + Mod : a - b ;} inline int Cmul ( int a , int b ) { return a * b % Mod ;} inline int Cmod ( int a ) { return ( a % Mod + Mod ) % Mod ;} inline int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ;} inline int qpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} inline int qmul ( int a , int b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} template < typename T > inline T power ( T x ) { return x * x ;} } using namespace MyTool ; inline void file () { freopen ( \".in\" , \"r\" , stdin ); freopen ( \".out\" , \"w\" , stdout ); return ; } bool Mbe ; namespace LgxTpre { static const int MAX = 500010 ; static const int inf = 2147483647 ; static const int INF = 4557430888798830399 ; static const int mod = 1e9 + 7 ; static const int bas = 131 ; inline void lmy_forever () { } } bool Med ; signed main () { // file(); fprintf ( stderr , \"%.3lf MB \\n \" ,( & Med -& Mbe ) / 1048576.0 ); int Tbe = clock (); LgxTpre :: lmy_forever (); int Ted = clock (); cerr << 1e3 * ( Ted - Tbe ) / CLOCKS_PER_SEC << \" ms \\n \" ; return ( 0-0 ); }","title":"\u5e38\u7528\u7f3a\u7701\u6e90"},{"location":"ds/DSU/","text":"\u666e\u901a\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( y ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } \u53ef\u64a4\u9500\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace RDSU { int N ; int fa [ MAX ], siz [ MAX ]; struct dsu { int x , fx , siz ; dsu ( int X = 0 , int Fx = 0 , int Siz = 0 ) { x = X , fx = Fx , siz = Siz ;} } stk [ MAX ]; int top ; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} inline int find ( int x ) { while ( x != fa [ x ]) x = fa [ x ]; return x ;} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); stk [ ++ top ] = dsu ( x , fa [ x ], siz [ x ]), stk [ ++ top ] = dsu ( y , fa [ y ], siz [ y ]); siz [ x ] += siz [ y ], fa [ y ] = x ; } inline void back ( int last ) { while ( top > last ) fa [ stk [ top ]. x ] = stk [ top ]. fx , siz [ stk [ top ]. x ] = stk [ top ]. siz , -- top ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u5e76\u67e5\u96c6"},{"location":"ds/LCT/","text":"\u901a\u7528\u6a21\u677f\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"LCT"},{"location":"ds/LCT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"\u901a\u7528\u6a21\u677f\uff1a"},{"location":"graph/MST/","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/cstree/","text":"","title":"\u5706\u65b9\u6811"},{"location":"graph/flow/","text":"\u6700\u5927\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } } \u8d39\u7528\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u7f51\u7edc\u6d41"},{"location":"graph/flow/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } }","title":"\u6700\u5927\u6d41\uff1a"},{"location":"graph/flow/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u8d39\u7528\u6d41\uff1a"},{"location":"graph/shortpath/","text":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } } SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } } SPFA \u5224\u8d1f\u73af\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } }","title":"\u6700\u77ed\u8def\u76f8\u5173"},{"location":"graph/shortpath/#dijktra","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } }","title":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } }","title":"SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } }","title":"SPFA \u5224\u8d1f\u73af\uff1a"},{"location":"graph/tarjan/","text":"","title":"tarjan"},{"location":"math/Pollard_Rho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 namespace Prime_Check { int mix , seed , step ; static const int P [] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }; static const int Pcnt = 12 ; inline int qmul ( int a , int b , int mod ) { int ans = a * b - ( int )(( long double ) a * b / mod + 0.5 ) * mod ; return ans < 0 ? ans + mod : ans ;} inline int qpow ( int a , int b , int mod ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a , mod ); a = qmul ( a , a , mod ); b >>= 1 ;} return res ;} inline int f ( int x , int mod ) { return ( qmul ( x , x , mod ) + seed ) % mod ;} inline int randoom ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution range ( l , r ); return range ( sd ); } inline bool Miller_Robin ( int x ) { if ( x <= 2 ) return x == 2 ; int y_ = x -1 ; while ( ! ( y_ & 1 )) y_ >>= 1 ; for ( int i = 0 ; i < Pcnt ; ++ i ) { if ( x == P [ i ]) return 1 ; int flag = 0 , y = _y , z = qpow ( P [ i ], y , x ); if ( z == 1 ) flag = 1 ; else while ( y < x -1 ) { if ( z == x -1 ) { flag = 1 ; break ;} y <<= 1 , z = qmul ( z , z , x ); } if ( ! flag ) return 0 ; } return 1 ; } inline int floyd ( int x ) { seed = randoom ( 0 , x -1 ); int fast , slow , res = 1 ; fast = slow = randoom ( 0 , x -1 ); fast = f ( fast , x ); for ( int i = 0 ; slow != fast ; ++ i ) { res = qmul ( res ,( fast - slow ) % x + x , x ); if ( ! res ) res = ( fast - slow ) % x + x ; if ( i % step == 0 ) { int g = gcd ( res , x ); if ( g != 1 ) return g ; res = 1 ;} slow = f ( slow , x ), fast = f ( f ( fast , x ), x ); } return gcd ( res , x ); } inline void Pollard_Rho ( int x ) { if ( x == 1 ) return ; if ( Miller_Robin ( x )) return cmax ( mix , x ); int k = 1 ; step = (( int ) log ( x )) << 1 | 1 ; while ( k == 1 ) k = floyd ( x ); Pollard_Rho ( k ), Pollard_Rho ( x / k ); } inline int solve ( int n ) { mix = 0 ; Pollard_Rho ( n ); if ( mix == n ) return -1 ; else return mix ; } }","title":"Pollard_Rho"}]}