{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 \u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\uff0c\u4e0d\u8fc7\u5927\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u5e38\u7528\u7f3a\u7701\u6e90 \uff0c\u5982\u679c\u5355\u72ec\u4f7f\u7528\u67d0\u4e2a\u6a21\u677f\u53ef\u80fd\u4f1a\u51fa\u73b0\u7f3a\u5931\u7684\u5b8f\u5b9a\u4e49\u7b49\u95ee\u9898 \u5982\u679c\u6709\u6a21\u677f\u4e0d\u660e\u767d\u5177\u4f53\u600e\u4e48\u4f7f\u7528\u7684\u8bdd\uff0c\u53ef\u4ee5\u8054\u7cfb \\(\\mathcal{LgxTpre}\\) \u6d1b\u8c37 QQ \u53f7\u7801\uff1a1475259438\uff0c\u9a8c\u8bc1\u7b54\u6848\uff1a\u4e50\u5b64\u661f","title":"Start"},{"location":"#home","text":"\u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\uff0c\u4e0d\u8fc7\u5927\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u5e38\u7528\u7f3a\u7701\u6e90 \uff0c\u5982\u679c\u5355\u72ec\u4f7f\u7528\u67d0\u4e2a\u6a21\u677f\u53ef\u80fd\u4f1a\u51fa\u73b0\u7f3a\u5931\u7684\u5b8f\u5b9a\u4e49\u7b49\u95ee\u9898 \u5982\u679c\u6709\u6a21\u677f\u4e0d\u660e\u767d\u5177\u4f53\u600e\u4e48\u4f7f\u7528\u7684\u8bdd\uff0c\u53ef\u4ee5\u8054\u7cfb \\(\\mathcal{LgxTpre}\\) \u6d1b\u8c37 QQ \u53f7\u7801\uff1a1475259438\uff0c\u9a8c\u8bc1\u7b54\u6848\uff1a\u4e50\u5b64\u661f","title":"Home"},{"location":"ATCF_default_source/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <bits/stdc++.h> #define int long long #define MAX 100010 #define INF 4557430888798830399 #define eb emplace_back #define fi first #define se second using namespace std ; const int mod = 998244353 ; inline void Madd ( int & a , int b ){ a = a + b >= mod ? a + b - mod : a + b ;} inline void Mdel ( int & a , int b ){ a = a - b < 0 ? a - b + mod : a - b ;} inline void Mmul ( int & a , int b ){ a = a * b % mod ;} inline int Cadd ( int a , int b ){ return a + b >= mod ? a + b - mod : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + mod : a - b ;} inline int Cmul ( int a , int b ){ return a * b % mod ;} int n , a [ MAX ], ans ; inline void solve () { } signed main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); int T = 1 ; //cin>>T; while ( T -- ) solve (); return ( 0-0 ); }","title":"AT/CF\u7f3a\u7701\u6e90"},{"location":"default_source/","text":"\u73af\u5883\u914d\u7f6e\uff1a -lm -Wall -Wl,--stack=536870912 -O2 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #include <bits/stdc++.h> #define ld long double #define ui unsigned int #define ull unsigned long long #define int long long #define eb emplace_back #define pb pop_back #define ins insert #define mp make_pair #define pii pair<int,int> #define fi first #define se second #define power(x) ((x)*(x)) #define gcd(x,y) (__gcd((x),(y))) #define lcm(x,y) ((x)*(y)/gcd((x),(y))) #define lg(x,y) (__lg((x),(y))) using namespace std ; namespace FastIO { template < typename T = int > inline T read () { T s = 0 , w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s * 10 ) + ( c ^ 48 ), c = getchar (); return s * w ; } template < typename T > inline void read ( T & s ) { s = 0 ; int w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s * 10 ) + ( c ^ 48 ), c = getchar (); s = s * w ; } template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ) { read ( x ), read ( args ...); } template < typename T > inline void write ( T x , char ch ) { if ( x < 0 ) x =- x , putchar ( '-' ); static char stk [ 25 ]; int top = 0 ; do { stk [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( stk [ -- top ]); if ( ch != '~' ) putchar ( ch ); return ; } } using namespace FastIO ; namespace MTool { #define TA template<typename T,typename... Args> #define TT template<typename T> static const int Mod = 998244353 ; TT inline void Swp ( T & a , T & b ) { T t = a ; a = b ; b = t ;} TT inline void cmax ( T & a , T b ) { a = max ( a , b );} TT inline void cmin ( T & a , T b ) { a = min ( a , b );} TA inline void cmax ( T & a , T b , Args ... args ) { a = max ({ a , b , args ...});} TA inline void cmin ( T & a , T b , Args ... args ) { a = min ({ a , b , args ...});} TT inline void Madd ( T & a , T b ) { a = a + b >= Mod ? a + b - Mod : a + b ;} TT inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} TT inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} TT inline void Mmod ( T & a ) { a = ( a % Mod + Mod ) % Mod ;} TT inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} TT inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} TT inline T Cmul ( T a , T b ) { return a * b % Mod ;} TT inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} TA inline void Madd ( T & a , T b , Args ... args ) { Madd ( a , Cadd ( b , args ...));} TA inline void Mdel ( T & a , T b , Args ... args ) { Mdel ( a , Cadd ( b , args ...));} TA inline void Mmul ( T & a , T b , Args ... args ) { Mmul ( a , Cmul ( b , args ...));} TA inline T Cadd ( T a , T b , Args ... args ) { return Cadd ( Cadd ( a , b ), args ...);} TA inline T Cdel ( T a , T b , Args ... args ) { return Cdel ( Cdel ( a , b ), args ...);} TA inline T Cmul ( T a , T b , Args ... args ) { return Cmul ( Cmul ( a , b ), args ...);} TT inline T qpow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} TT inline T qmul ( T a , T b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} TT inline T spow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} TT inline void exgcd ( T A , T B , T & X , T & Y ) { if ( ! B ) return X = 1 , Y = 0 , void (); exgcd ( B , A % B , Y , X ), Y -= X * ( A / B );} TT inline T Ginv ( T x ) { T A = 0 , B = 0 ; exgcd ( x , Mod , A , B ); return Cmod ( A );} #undef TT #undef TA } using namespace MTool ; inline void file () { freopen ( \".in\" , \"r\" , stdin ); freopen ( \".out\" , \"w\" , stdout ); return ; } bool Mbe ; namespace LgxTpre { static const int MAX = 100010 ; static const int inf = 2147483647 ; static const int INF = 4557430888798830399 ; static const int mod = 1e9 + 7 ; static const int bas = 131 ; inline void mian () { return ; } } bool Med ; signed main () { // file(); fprintf ( stderr , \"%.3lf MB \\n \" , abs ( & Med -& Mbe ) / 1048576.0 ); int Tbe = clock (); LgxTpre :: mian (); int Ted = clock (); cerr << 1e3 * ( Ted - Tbe ) / CLOCKS_PER_SEC << \" ms \\n \" ; return ( 0-0 ); }","title":"\u5e38\u7528\u7f3a\u7701\u6e90"},{"location":"ds/BST/","text":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } } \u6587\u827a\u5e73\u8861\u6811 FHQ_Treap \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void down ( int i ) { if ( i ) tag [ i ] ^= 1 , Swp ( lson [ i ], rson [ i ]); } inline void pushdown ( int i ) { if ( tag [ i ]) down ( lson [ i ]), down ( rson [ i ]), tag [ i ] = 0 ; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( siz [ lson [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); down ( mid ); root = merge ( merge ( l , mid ), r ); } }","title":"\u5e73\u8861\u6811"},{"location":"ds/BST/#fhq_treap","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } }","title":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap"},{"location":"ds/BST/#fhq_treap_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void down ( int i ) { if ( i ) tag [ i ] ^= 1 , Swp ( lson [ i ], rson [ i ]); } inline void pushdown ( int i ) { if ( tag [ i ]) down ( lson [ i ]), down ( rson [ i ]), tag [ i ] = 0 ; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( siz [ lson [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); down ( mid ); root = merge ( merge ( l , mid ), r ); } }","title":"\u6587\u827a\u5e73\u8861\u6811 FHQ_Treap"},{"location":"ds/DSU/","text":"\u666e\u901a\u5e76\u67e5\u96c6 \u00b6 1 2 3 4 5 6 7 8 9 namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } \u53ef\u64a4\u9500\u5e76\u67e5\u96c6 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace RDSU { int N ; int fa [ MAX ], siz [ MAX ]; struct dsu { int x , fx , siz ; dsu ( int X = 0 , int Fx = 0 , int Siz = 0 ) { x = X , fx = Fx , siz = Siz ;} } stk [ MAX ]; int top ; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} inline int find ( int x ) { while ( x != fa [ x ]) x = fa [ x ]; return x ;} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); stk [ ++ top ] = dsu ( x , fa [ x ], siz [ x ]), stk [ ++ top ] = dsu ( y , fa [ y ], siz [ y ]); siz [ x ] += siz [ y ], fa [ y ] = x ; } inline void back ( int last ) { while ( top > last ) fa [ stk [ top ]. x ] = stk [ top ]. fx , siz [ stk [ top ]. x ] = stk [ top ]. siz , -- top ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u5e76\u67e5\u96c6"},{"location":"ds/DSU/#_1","text":"1 2 3 4 5 6 7 8 9 namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u666e\u901a\u5e76\u67e5\u96c6"},{"location":"ds/DSU/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace RDSU { int N ; int fa [ MAX ], siz [ MAX ]; struct dsu { int x , fx , siz ; dsu ( int X = 0 , int Fx = 0 , int Siz = 0 ) { x = X , fx = Fx , siz = Siz ;} } stk [ MAX ]; int top ; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} inline int find ( int x ) { while ( x != fa [ x ]) x = fa [ x ]; return x ;} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); stk [ ++ top ] = dsu ( x , fa [ x ], siz [ x ]), stk [ ++ top ] = dsu ( y , fa [ y ], siz [ y ]); siz [ x ] += siz [ y ], fa [ y ] = x ; } inline void back ( int last ) { while ( top > last ) fa [ stk [ top ]. x ] = stk [ top ]. fx , siz [ stk [ top ]. x ] = stk [ top ]. siz , -- top ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u53ef\u64a4\u9500\u5e76\u67e5\u96c6"},{"location":"ds/LCT/","text":"\u901a\u7528\u6a21\u677f \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void down ( int i ) { if ( ! i ) return ; tag [ i ] ^= 1 , Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]);} inline void pushdown ( int i ) { if ( tag [ i ]) down ( ch [ i ][ 0 ]), down ( ch [ i ][ 1 ]), tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), down ( x );} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"LCT"},{"location":"ds/LCT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void down ( int i ) { if ( ! i ) return ; tag [ i ] ^= 1 , Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]);} inline void pushdown ( int i ) { if ( tag [ i ]) down ( ch [ i ][ 0 ]), down ( ch [ i ][ 1 ]), tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), down ( x );} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"\u901a\u7528\u6a21\u677f"},{"location":"ds/LT/","text":"pushdown \u91cc\u9762\u53ef\u4ee5\u6253\u52a0\u6cd5\u3001\u4e58\u6cd5\u6807\u8bb0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 namespace LeftistTree { int N ; int val [ MAX ], lson [ MAX ], rson [ MAX ], dis [ MAX ], rt [ MAX ], tag [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) rt [ i ] = i ;} inline void pushdown ( int i ) {} int find ( int x ) { if ( rt [ x ] == x ) return x ; return rt [ x ] = find ( rt [ x ]);} int mer ( int x , int y ) { if ( ! x ||! y ) return x | y ; if ( val [ x ] > val [ y ] || ( val [ x ] == val [ y ] && x > y )) Swp ( x , y ); pushdown ( x ), rson [ x ] = mer ( rson [ x ], y ); if ( dis [ rson [ x ]] > dis [ lson [ x ]]) Swp ( lson [ x ], rson [ x ]); dis [ x ] = dis [ rson [ x ]] + 1 ; return x ; } inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x == y ) return ; rt [ x ] = rt [ y ] = mer ( x , y ); } void delet ( int x ) { x = find ( x ); rt [ x ] = rt [ lson [ x ]] = rt [ rson [ x ]] = mer ( lson [ x ], rson [ x ]); } inline int build () { queue < int > q ; for ( int i = 1 ; i <= N ; ++ i ) q . push ( i ); while ( q . size () != 1 ) { int x = q . front (); q . pop (); int y = q . front (); q . pop (); x = mer ( x , y ), q . push ( x ); } return q . front (); } }","title":"\u5de6\u504f\u6811"},{"location":"ds/SGT/","text":"\u666e\u901a\u61d2\u6807\u8bb0\u7ebf\u6bb5\u6811 \u00b6 \u652f\u6301\u533a\u4fee\u533a\u67e5\uff0c\u81ea\u5b9a\u4e49\u6807\u8bb0\u548c\u6570\u636e\u7684\u7c7b\u578b\uff0c\u53ef\u4ee5\u6df7\u642d\u5176\u4ed6\u591a\u79cd\u6a21\u677f\u3002\u7ef4\u62a4\u590d\u6742\u7684\u533a\u95f4\u4fe1\u606f\u76f4\u63a5\u91cd\u8f7d\u52a0\u6cd5\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 namespace SegmentTree { template < class Info , class Tag > struct SGT { int n ; vector < Info > info ; vector < Tag > tag ; SGT ( int N = 0 ) : n ( N ) {} SGT ( int N = 0 , Info Inf = Info ()) { init ( vector ( N , Inf ));} template < typename T > SGT ( vector < T > a ) { init ( a );} template < typename T > inline void init ( vector < T > ini ) { n = ini . size () -1 ; info . assign ( 4 << __lg ( n ), Info ()), tag . assign ( 4 << __lg ( n ), Tag ()); auto build = [ & ]( auto build , int i , int l , int r ) -> void { if ( l == r ) return info [ i ] = ini [ l ], void (); int mid = ( l + r ) >> 1 ; build ( build , i << 1 , l , mid ), build ( build , i << 1 | 1 , mid + 1 , r ); pushup ( i ); }; build ( build , 1 , 1 , n ); } inline void pushup ( int i ) { info [ i ] = info [ i << 1 ] + info [ i << 1 | 1 ];} inline void apply ( int i , const Tag & tmp ) { info [ i ]. apply ( tmp ), tag [ i ]. apply ( tmp );} inline void pushdown ( int i ) { apply ( i << 1 , tag [ i ]), apply ( i << 1 | 1 , tag [ i ]), tag [ i ] = Tag ();} void modify ( int i , int l , int r , int L , int R , const Tag & tmp ) { if ( l > r ) return ; if ( l <= L && R <= r ) return apply ( i , tmp ), void (); pushdown ( i ); int mid = ( L + R ) >> 1 ; if ( l <= mid ) modify ( i << 1 , l , r , L , mid , tmp ); if ( r > mid ) modify ( i << 1 | 1 , l , r , mid + 1 , R , tmp ); pushup ( i ); } inline void modify ( int l , int r , const Tag & tmp ) { modify ( 1 , l , r , 1 , n , tmp );} void cover ( int i , int x , int L , int R , const Info & tmp ) { if ( L == R ) return info [ i ] = tmp , void (); pushdown ( i ); int mid = ( L + R ) >> 1 ; if ( x <= mid ) cover ( i << 1 , x , L , mid , tmp ); else cover ( i << 1 | 1 , x , mid + 1 , R , tmp ); pushup ( i ); } inline void cover ( int x , const Info & tmp ) { cover ( 1 , x , 1 , n , tmp );} Info query ( int i , int l , int r , int L , int R ) { if ( R < l || r < L ) return Info (); if ( l <= L && R <= r ) return info [ i ]; pushdown ( i ); int mid = ( L + R ) >> 1 ; return query ( i << 1 , l , r , L , mid ) + query ( i << 1 | 1 , l , r , mid + 1 , R ); } inline Info query ( int l , int r ) { return query ( 1 , l , r , 1 , n );} }; struct Tag { }; struct Info { }; }","title":"\u7ebf\u6bb5\u6811"},{"location":"ds/SGT/#_1","text":"\u652f\u6301\u533a\u4fee\u533a\u67e5\uff0c\u81ea\u5b9a\u4e49\u6807\u8bb0\u548c\u6570\u636e\u7684\u7c7b\u578b\uff0c\u53ef\u4ee5\u6df7\u642d\u5176\u4ed6\u591a\u79cd\u6a21\u677f\u3002\u7ef4\u62a4\u590d\u6742\u7684\u533a\u95f4\u4fe1\u606f\u76f4\u63a5\u91cd\u8f7d\u52a0\u6cd5\u5373\u53ef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 namespace SegmentTree { template < class Info , class Tag > struct SGT { int n ; vector < Info > info ; vector < Tag > tag ; SGT ( int N = 0 ) : n ( N ) {} SGT ( int N = 0 , Info Inf = Info ()) { init ( vector ( N , Inf ));} template < typename T > SGT ( vector < T > a ) { init ( a );} template < typename T > inline void init ( vector < T > ini ) { n = ini . size () -1 ; info . assign ( 4 << __lg ( n ), Info ()), tag . assign ( 4 << __lg ( n ), Tag ()); auto build = [ & ]( auto build , int i , int l , int r ) -> void { if ( l == r ) return info [ i ] = ini [ l ], void (); int mid = ( l + r ) >> 1 ; build ( build , i << 1 , l , mid ), build ( build , i << 1 | 1 , mid + 1 , r ); pushup ( i ); }; build ( build , 1 , 1 , n ); } inline void pushup ( int i ) { info [ i ] = info [ i << 1 ] + info [ i << 1 | 1 ];} inline void apply ( int i , const Tag & tmp ) { info [ i ]. apply ( tmp ), tag [ i ]. apply ( tmp );} inline void pushdown ( int i ) { apply ( i << 1 , tag [ i ]), apply ( i << 1 | 1 , tag [ i ]), tag [ i ] = Tag ();} void modify ( int i , int l , int r , int L , int R , const Tag & tmp ) { if ( l > r ) return ; if ( l <= L && R <= r ) return apply ( i , tmp ), void (); pushdown ( i ); int mid = ( L + R ) >> 1 ; if ( l <= mid ) modify ( i << 1 , l , r , L , mid , tmp ); if ( r > mid ) modify ( i << 1 | 1 , l , r , mid + 1 , R , tmp ); pushup ( i ); } inline void modify ( int l , int r , const Tag & tmp ) { modify ( 1 , l , r , 1 , n , tmp );} void cover ( int i , int x , int L , int R , const Info & tmp ) { if ( L == R ) return info [ i ] = tmp , void (); pushdown ( i ); int mid = ( L + R ) >> 1 ; if ( x <= mid ) cover ( i << 1 , x , L , mid , tmp ); else cover ( i << 1 | 1 , x , mid + 1 , R , tmp ); pushup ( i ); } inline void cover ( int x , const Info & tmp ) { cover ( 1 , x , 1 , n , tmp );} Info query ( int i , int l , int r , int L , int R ) { if ( R < l || r < L ) return Info (); if ( l <= L && R <= r ) return info [ i ]; pushdown ( i ); int mid = ( L + R ) >> 1 ; return query ( i << 1 , l , r , L , mid ) + query ( i << 1 | 1 , l , r , mid + 1 , R ); } inline Info query ( int l , int r ) { return query ( 1 , l , r , 1 , n );} }; struct Tag { }; struct Info { }; }","title":"\u666e\u901a\u61d2\u6807\u8bb0\u7ebf\u6bb5\u6811"},{"location":"graph/MST/","text":"Kruskal \u6700\u5c0f\u751f\u6210\u6811 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace Kruskal { using piii = pair < pair < int , int > , int > ; vector < piii > E ; int cnt , sum ; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } using namespace DSU ; inline void solve () { N = n , init (); sort ( E . begin (), E . end (),[ & ]( piii a , piii b ){ return a . se < b . se ;}); for ( auto [ point , val ] : E ) { int x = point . fi , y = point . se ; if ( check ( x , y )) continue ; merge ( x , y ), sum += val ; if ( ++ cnt == n -1 ) break ; } } } Prim \u6700\u5c0f\u751f\u6210\u6811 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 namespace Prim { vector < pii > G [ MAX ]; int dis [ MAX ], vis [ MAX ], now = 1 ; int sum , tot ; inline void solve () { for ( int i = 2 ; i <= n ; ++ i ) dis [ i ] = INF ; for ( auto [ to , val ] : G [ 1 ]) cmin ( dis [ to ], val ); while ( ++ tot < n ) { int mix = INF ; vis [ now ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! vis [ i ] && dis [ i ] < mix ) mix = dis [ i ], now = i ; sum += mix ; for ( auto [ to , val ] : G [ now ]) if ( dis [ to ] > val &&! vis [ to ]) dis [ to ] = val ; } } } Boruvka \u6700\u5c0f\u751f\u6210\u6811 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace Boruvka { using piii = pair < pair < int , int > , int > ; vector < piii > E ; int cnt , sum , flag ; int best [ MAX ], used [ MAX * 40 ]; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} } using namespace DSU ; inline void solve () { auto better = [ & ]( int a , int b ) -> bool { if ( ! ( ~ b )) return 1 ; if ( E [ a ]. se != E [ b ]. se ) return E [ a ]. se < E [ b ]. se ; return a < b ; }; N = n , init (); do { flag = 0 , memset ( best , -1 , sizeof best ); for ( int i = 0 ; i < (( int ) E . size ()); ++ i ) { int x = E [ i ]. fi . fi , y = E [ i ]. fi . se ; x = find ( x ), y = find ( y ); if ( x == y || used [ i ]) continue ; if ( better ( i , best [ x ])) best [ x ] = i ; if ( better ( i , best [ y ])) best [ y ] = i ; } for ( int i = 1 , id = best [ i ]; i <= n ; ++ i , id = best [ i ]) if ( ~ id &&! used [ id ]) flag = 1 , ++ cnt , sum += E [ id ]. se , merge ( E [ id ]. fi . fi , E [ id ]. fi . se ), used [ id ] = 1 ; } while ( flag ); } } using namespace Boruvka ; Kruskal \u91cd\u6784\u6811 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace KruskalTree { using piii = pair < pair < int , int > , int > ; vector < piii > E ; vector < int > G [ MAX ]; int cnt , val [ MAX ]; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } using namespace DSU ; inline void solve () { N = n , init (); sort ( E . begin (), E . end (),[ & ]( piii a , piii b ){ return a . se < b . se ;}); for ( auto [ point , Eval ] : E ) { int x = point . fi , y = point . se ; if ( check ( x , y )) continue ; ++ cnt , merge ( x , y ), val [ cnt + n ] = Eval ; G [ cnt + n ]. eb ( x ), G [ x ]. eb ( cnt + n ), G [ cnt + n ]. eb ( y ), G [ y ]. eb ( cnt + n ); if ( cnt == n -1 ) break ; } } }","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/MST/#kruskal","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace Kruskal { using piii = pair < pair < int , int > , int > ; vector < piii > E ; int cnt , sum ; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } using namespace DSU ; inline void solve () { N = n , init (); sort ( E . begin (), E . end (),[ & ]( piii a , piii b ){ return a . se < b . se ;}); for ( auto [ point , val ] : E ) { int x = point . fi , y = point . se ; if ( check ( x , y )) continue ; merge ( x , y ), sum += val ; if ( ++ cnt == n -1 ) break ; } } }","title":"Kruskal \u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/MST/#prim","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 namespace Prim { vector < pii > G [ MAX ]; int dis [ MAX ], vis [ MAX ], now = 1 ; int sum , tot ; inline void solve () { for ( int i = 2 ; i <= n ; ++ i ) dis [ i ] = INF ; for ( auto [ to , val ] : G [ 1 ]) cmin ( dis [ to ], val ); while ( ++ tot < n ) { int mix = INF ; vis [ now ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! vis [ i ] && dis [ i ] < mix ) mix = dis [ i ], now = i ; sum += mix ; for ( auto [ to , val ] : G [ now ]) if ( dis [ to ] > val &&! vis [ to ]) dis [ to ] = val ; } } }","title":"Prim \u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/MST/#boruvka","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace Boruvka { using piii = pair < pair < int , int > , int > ; vector < piii > E ; int cnt , sum , flag ; int best [ MAX ], used [ MAX * 40 ]; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} } using namespace DSU ; inline void solve () { auto better = [ & ]( int a , int b ) -> bool { if ( ! ( ~ b )) return 1 ; if ( E [ a ]. se != E [ b ]. se ) return E [ a ]. se < E [ b ]. se ; return a < b ; }; N = n , init (); do { flag = 0 , memset ( best , -1 , sizeof best ); for ( int i = 0 ; i < (( int ) E . size ()); ++ i ) { int x = E [ i ]. fi . fi , y = E [ i ]. fi . se ; x = find ( x ), y = find ( y ); if ( x == y || used [ i ]) continue ; if ( better ( i , best [ x ])) best [ x ] = i ; if ( better ( i , best [ y ])) best [ y ] = i ; } for ( int i = 1 , id = best [ i ]; i <= n ; ++ i , id = best [ i ]) if ( ~ id &&! used [ id ]) flag = 1 , ++ cnt , sum += E [ id ]. se , merge ( E [ id ]. fi . fi , E [ id ]. fi . se ), used [ id ] = 1 ; } while ( flag ); } } using namespace Boruvka ;","title":"Boruvka \u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/MST/#kruskal_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace KruskalTree { using piii = pair < pair < int , int > , int > ; vector < piii > E ; vector < int > G [ MAX ]; int cnt , val [ MAX ]; namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } using namespace DSU ; inline void solve () { N = n , init (); sort ( E . begin (), E . end (),[ & ]( piii a , piii b ){ return a . se < b . se ;}); for ( auto [ point , Eval ] : E ) { int x = point . fi , y = point . se ; if ( check ( x , y )) continue ; ++ cnt , merge ( x , y ), val [ cnt + n ] = Eval ; G [ cnt + n ]. eb ( x ), G [ x ]. eb ( cnt + n ), G [ cnt + n ]. eb ( y ), G [ y ]. eb ( cnt + n ); if ( cnt == n -1 ) break ; } } }","title":"Kruskal \u91cd\u6784\u6811"},{"location":"graph/flow/","text":"\u6700\u5927\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } } \u8d39\u7528\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u7f51\u7edc\u6d41"},{"location":"graph/flow/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } }","title":"\u6700\u5927\u6d41"},{"location":"graph/flow/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u8d39\u7528\u6d41"},{"location":"graph/shortpath/","text":"dijktra \u5355\u6e90\u6700\u77ed\u8def \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } } SPFA \u5355\u6e90\u6700\u77ed\u8def \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } } SPFA \u5224\u8d1f\u73af \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } } Johnson\u5168\u6e90\u6700\u77ed\u8def \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"\u6700\u77ed\u8def\u76f8\u5173"},{"location":"graph/shortpath/#dijktra","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } }","title":"dijktra \u5355\u6e90\u6700\u77ed\u8def"},{"location":"graph/shortpath/#spfa","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } }","title":"SPFA \u5355\u6e90\u6700\u77ed\u8def"},{"location":"graph/shortpath/#spfa_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } }","title":"SPFA \u5224\u8d1f\u73af"},{"location":"graph/shortpath/#johnson","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"Johnson\u5168\u6e90\u6700\u77ed\u8def"},{"location":"graph/tarjan/","text":"\u5f3a\u8054\u901a\u5206\u91cf\u7f29\u70b9 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace SCC { vector < int > G [ MAX ], T [ MAX ], scc [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int vis [ MAX ], stk [ MAX ], top ; int col [ MAX ], colsiz [ MAX ], num ; void tarjan ( int now ) { dfn [ now ] = low [ now ] =++ tot ; stk [ ++ top ] = now , vis [ now ] = 1 ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) tarjan ( to ), cmin ( low [ now ], low [ to ]); else if ( vis [ to ]) cmin ( low [ now ], dfn [ to ]); if ( low [ now ] == dfn [ now ]) { col [ now ] =++ num , ++ colsiz [ num ], vis [ now ] = 0 , scc [ num ]. eb ( now ); while ( stk [ top ] != now ) col [ stk [ top ]] = num , ++ colsiz [ num ], scc [ num ]. eb ( stk [ top ]), vis [ stk [ top ]] = 0 , -- top ; -- top ; } } inline void ShrinkPoint () { for ( int now = 1 ; now <= n ; ++ now ) for ( auto to : G [ now ]) if ( col [ now ] != col [ to ]) T [ col [ now ]]. eb ( col [ to ]); } } \u5272\u70b9 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace CutPoint { vector < int > G [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int root , cut [ MAX ], num ; void tarjan ( int now ) { int flag = 0 ; low [ now ] = dfn [ now ] =++ tot ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) { tarjan ( to ), cmin ( low [ now ], low [ to ]); if ( low [ to ] >= dfn [ now ]) { ++ flag ; if (( now != root || flag > 1 ) &&! cut [ now ]) cut [ now ] = 1 , ++ num ; } } else cmin ( low [ now ], dfn [ to ]); } } \u5272\u8fb9 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace CutEdge { struct edge { int nex , to ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y ; return ; } int dfn [ MAX ], low [ MAX ], tot ; int root , bridge [ MAX ], num ; void tarjan ( int now , int nowi ) { dfn [ now ] = low [ now ] =++ tot ; for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! dfn [ to ]) { tarjan ( to , i ), cmin ( low [ now ], low [ to ]); if ( low [ to ] > dfn [ now ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; } else if ( i != ( nowi ^ 1 )) cmin ( low [ now ], dfn [ to ]); } } \u70b9\u53cc\u8054\u901a\u5206\u91cf \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace PDCC { vector < int > G [ MAX ], pdcc [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int stk [ MAX ], top , num ; void tarjan ( int now , int father ) { int son = 0 ; dfn [ now ] = low [ now ] =++ tot ; stk [ ++ top ] = now ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) { tarjan ( to , now ), cmin ( low [ now ], low [ to ]), ++ son ; if ( low [ to ] >= dfn [ now ]) { ++ num , pdcc [ num ]. eb ( now ); do pdcc [ num ]. eb ( stk [ top ]), -- top ; while ( stk [ top + 1 ] != to ); } } else if ( to != father ) cmin ( low [ now ], dfn [ to ]); if ( ! son &&! father ) pdcc [ ++ num ]. eb ( now ); } } \u8fb9\u53cc\u8fde\u901a\u5206\u91cf \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace EDCC { struct edge { int nex , to ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y ; return ; } int dfn [ MAX ], low [ MAX ], tot ; int root , bridge [ MAX ], col [ MAX ], num ; vector < int > edcc [ MAX ]; void tarjan ( int now , int nowi ) { dfn [ now ] = low [ now ] =++ tot ; for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! dfn [ to ]) { tarjan ( to , i ), cmin ( low [ now ], low [ to ]); if ( low [ to ] > dfn [ now ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; } else if ( i != ( nowi ^ 1 )) cmin ( low [ now ], dfn [ to ]); } void dfs ( int now ) { col [ now ] = num ; if ( now ) edcc [ num ]. eb ( now ); for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! col [ to ] &&! bridge [ i ]) dfs ( to ); } }","title":"\u8fde\u901a\u6027\u76f8\u5173"},{"location":"graph/tarjan/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace SCC { vector < int > G [ MAX ], T [ MAX ], scc [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int vis [ MAX ], stk [ MAX ], top ; int col [ MAX ], colsiz [ MAX ], num ; void tarjan ( int now ) { dfn [ now ] = low [ now ] =++ tot ; stk [ ++ top ] = now , vis [ now ] = 1 ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) tarjan ( to ), cmin ( low [ now ], low [ to ]); else if ( vis [ to ]) cmin ( low [ now ], dfn [ to ]); if ( low [ now ] == dfn [ now ]) { col [ now ] =++ num , ++ colsiz [ num ], vis [ now ] = 0 , scc [ num ]. eb ( now ); while ( stk [ top ] != now ) col [ stk [ top ]] = num , ++ colsiz [ num ], scc [ num ]. eb ( stk [ top ]), vis [ stk [ top ]] = 0 , -- top ; -- top ; } } inline void ShrinkPoint () { for ( int now = 1 ; now <= n ; ++ now ) for ( auto to : G [ now ]) if ( col [ now ] != col [ to ]) T [ col [ now ]]. eb ( col [ to ]); } }","title":"\u5f3a\u8054\u901a\u5206\u91cf\u7f29\u70b9"},{"location":"graph/tarjan/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 namespace CutPoint { vector < int > G [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int root , cut [ MAX ], num ; void tarjan ( int now ) { int flag = 0 ; low [ now ] = dfn [ now ] =++ tot ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) { tarjan ( to ), cmin ( low [ now ], low [ to ]); if ( low [ to ] >= dfn [ now ]) { ++ flag ; if (( now != root || flag > 1 ) &&! cut [ now ]) cut [ now ] = 1 , ++ num ; } } else cmin ( low [ now ], dfn [ to ]); } }","title":"\u5272\u70b9"},{"location":"graph/tarjan/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace CutEdge { struct edge { int nex , to ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y ; return ; } int dfn [ MAX ], low [ MAX ], tot ; int root , bridge [ MAX ], num ; void tarjan ( int now , int nowi ) { dfn [ now ] = low [ now ] =++ tot ; for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! dfn [ to ]) { tarjan ( to , i ), cmin ( low [ now ], low [ to ]); if ( low [ to ] > dfn [ now ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; } else if ( i != ( nowi ^ 1 )) cmin ( low [ now ], dfn [ to ]); } }","title":"\u5272\u8fb9"},{"location":"graph/tarjan/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace PDCC { vector < int > G [ MAX ], pdcc [ MAX ]; int dfn [ MAX ], low [ MAX ], tot ; int stk [ MAX ], top , num ; void tarjan ( int now , int father ) { int son = 0 ; dfn [ now ] = low [ now ] =++ tot ; stk [ ++ top ] = now ; for ( auto to : G [ now ]) if ( ! dfn [ to ]) { tarjan ( to , now ), cmin ( low [ now ], low [ to ]), ++ son ; if ( low [ to ] >= dfn [ now ]) { ++ num , pdcc [ num ]. eb ( now ); do pdcc [ num ]. eb ( stk [ top ]), -- top ; while ( stk [ top + 1 ] != to ); } } else if ( to != father ) cmin ( low [ now ], dfn [ to ]); if ( ! son &&! father ) pdcc [ ++ num ]. eb ( now ); } }","title":"\u70b9\u53cc\u8054\u901a\u5206\u91cf"},{"location":"graph/tarjan/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace EDCC { struct edge { int nex , to ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y ; return ; } int dfn [ MAX ], low [ MAX ], tot ; int root , bridge [ MAX ], col [ MAX ], num ; vector < int > edcc [ MAX ]; void tarjan ( int now , int nowi ) { dfn [ now ] = low [ now ] =++ tot ; for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! dfn [ to ]) { tarjan ( to , i ), cmin ( low [ now ], low [ to ]); if ( low [ to ] > dfn [ now ]) bridge [ i ] = bridge [ i ^ 1 ] = 1 ; } else if ( i != ( nowi ^ 1 )) cmin ( low [ now ], dfn [ to ]); } void dfs ( int now ) { col [ now ] = num ; if ( now ) edcc [ num ]. eb ( now ); for ( int i = head [ now ], to = e [ i ]. to ; i ; i = e [ i ]. nex , to = e [ i ]. to ) if ( ! col [ to ] &&! bridge [ i ]) dfs ( to ); } }","title":"\u8fb9\u53cc\u8fde\u901a\u5206\u91cf"},{"location":"math/Basic/","text":"\u5e38\u7528\u8ba1\u6570\u9884\u5904\u7406\uff1a\u9636\u4e58\uff0c\u9006\u5143\uff0c\u7ec4\u5408\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace Math { int fac [ MAX ], inv [ MAX ], C [ MAX ][ MAX ]; inline void init ( int N ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; ++ i ) fac [ i ] = Cmul ( fac [ i -1 ], i ); inv [ N ] = qpow ( fac [ N ], Mod -2 ); for ( int i = N -1 ; i ; -- i ) inv [ i ] = Cmul ( inv [ i + 1 ], i + 1 ); C [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= N ; ++ i ) { for ( int j = 1 ; j <= N ; ++ j ) C [ i ][ j ] = Cadd ( C [ i -1 ][ j -1 ], C [ i -1 ][ j ]); C [ i ][ 0 ] = 1 ; } } }","title":"\u6570\u5b66\u57fa\u7840"},{"location":"math/Gauss/","text":"\u6c42\u89e3\u5f02\u6216\u65b9\u7a0b\u7ec4 \u00b6 \u4f20\u53c2 \\(n\\) \u662f\u65b9\u7a0b\u4e2a\u6570\uff0c \\(m\\) \u662f\u672a\u77e5\u5143\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 namespace Gauss_Xor { bitset < MAX > mat [ MAX ]; inline void Gauss ( int n , int m ) { int x = 0 , y = 0 ; for (; y < m ; ++ y ) { int now = x ; while ( now < n &&! mat [ now ][ y ]) ++ now ; if ( now == n ) continue ; swap ( mat [ x ], mat [ now ]); for ( int i = 0 ; i < n ; ++ i ) if ( i != x && mat [ i ][ y ]) mat [ i ] ^= mat [ x ]; ++ x ; } } } \u6c42\u89e3\u884c\u5217\u5f0f \u00b6 \u4f7f\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\uff0c\u642d\u914d ModNum \u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 namespace Determinant { vector < vector < int >> A ; inline int SolveDet () { int det = 1 , N = A . size () -1 ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = i + 1 ; j < N ; ++ j ) while ( A [ j ][ i ]) { int tmp = A [ i ][ i ] / A [ j ][ i ]; for ( int k = i ; k < N && tmp ; ++ k ) Mdel ( A [ i ][ k ], Cmul ( A [ j ][ k ], tmp )); swap ( A [ i ], A [ j ]), det =- det ; } Mmod ( det ); for ( int i = 0 ; i < N ; ++ i ) if ( A [ i ][ i ]) Mmul ( det , A [ i ][ i ]); return det ; } }","title":"\u9ad8\u65af\u6d88\u5143\u76f8\u5173"},{"location":"math/Gauss/#_1","text":"\u4f20\u53c2 \\(n\\) \u662f\u65b9\u7a0b\u4e2a\u6570\uff0c \\(m\\) \u662f\u672a\u77e5\u5143\u4e2a\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 namespace Gauss_Xor { bitset < MAX > mat [ MAX ]; inline void Gauss ( int n , int m ) { int x = 0 , y = 0 ; for (; y < m ; ++ y ) { int now = x ; while ( now < n &&! mat [ now ][ y ]) ++ now ; if ( now == n ) continue ; swap ( mat [ x ], mat [ now ]); for ( int i = 0 ; i < n ; ++ i ) if ( i != x && mat [ i ][ y ]) mat [ i ] ^= mat [ x ]; ++ x ; } } }","title":"\u6c42\u89e3\u5f02\u6216\u65b9\u7a0b\u7ec4"},{"location":"math/Gauss/#_2","text":"\u4f7f\u7528\u8f97\u8f6c\u76f8\u9664\u6cd5\uff0c\u642d\u914d ModNum \u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 namespace Determinant { vector < vector < int >> A ; inline int SolveDet () { int det = 1 , N = A . size () -1 ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = i + 1 ; j < N ; ++ j ) while ( A [ j ][ i ]) { int tmp = A [ i ][ i ] / A [ j ][ i ]; for ( int k = i ; k < N && tmp ; ++ k ) Mdel ( A [ i ][ k ], Cmul ( A [ j ][ k ], tmp )); swap ( A [ i ], A [ j ]), det =- det ; } Mmod ( det ); for ( int i = 0 ; i < N ; ++ i ) if ( A [ i ][ i ]) Mmul ( det , A [ i ][ i ]); return det ; } }","title":"\u6c42\u89e3\u884c\u5217\u5f0f"},{"location":"math/Pollard_Rho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 namespace Prime_Check { int mix , seed , step ; static const int P [] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }; static const int Pcnt = 12 ; inline int qmul ( int a , int b , int mod ) { int ans = a * b - ( int )(( long double ) a * b / mod + 0.5 ) * mod ; return ans < 0 ? ans + mod : ans ;} inline int qpow ( int a , int b , int mod ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a , mod ); a = qmul ( a , a , mod ); b >>= 1 ;} return res ;} inline int f ( int x , int mod ) { return ( qmul ( x , x , mod ) + seed ) % mod ;} inline int randoom ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline bool Miller_Robin ( int x ) { if ( x <= 2 ) return x == 2 ; int y_ = x -1 ; while ( ! ( y_ & 1 )) y_ >>= 1 ; for ( int i = 0 ; i < Pcnt ; ++ i ) { if ( x == P [ i ]) return 1 ; int flag = 0 , y = y_ , z = qpow ( P [ i ], y , x ); if ( z == 1 ) flag = 1 ; else while ( y < x -1 ) { if ( z == x -1 ) { flag = 1 ; break ;} y <<= 1 , z = qmul ( z , z , x ); } if ( ! flag ) return 0 ; } return 1 ; } inline int floyd ( int x ) { seed = randoom ( 0 , x -1 ); int fast , slow , res = 1 ; fast = slow = randoom ( 0 , x -1 ); fast = f ( fast , x ); for ( int i = 0 ; slow != fast ; ++ i ) { res = qmul ( res ,( fast - slow ) % x + x , x ); if ( ! res ) res = ( fast - slow ) % x + x ; if ( i % step == 0 ) { int g = gcd ( res , x ); if ( g != 1 ) return g ; res = 1 ;} slow = f ( slow , x ), fast = f ( f ( fast , x ), x ); } return gcd ( res , x ); } inline void Pollard_Rho ( int x ) { if ( x == 1 ) return ; if ( Miller_Robin ( x )) return cmax ( mix , x ); int k = 1 ; step = (( int ) log ( x )) << 1 | 1 ; while ( k == 1 ) k = floyd ( x ); Pollard_Rho ( k ), Pollard_Rho ( x / k ); } inline int solve ( int n ) { mix = 0 ; Pollard_Rho ( n ); if ( mix == n ) return -1 ; else return mix ; } }","title":"Pollard_Rho"},{"location":"math/Sieve/","text":"\u7ebf\u6027\u7b5b\u7d20\u6570\u3002 \u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570\uff1a \\(d_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570\uff0c \\(num_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u51fa\u73b0\u6b21\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c\uff1a \\(f_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c\uff0c \\(g_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 namespace Sieve { static const int N = 100000 ; static const int MAX = 10010 ; int vis [ N + 10 ], P [ MAX ], Pcnt ; inline void Linear_Sieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( ! i % P [ j ]) break ; } } return ; } int phi [ N + 10 ]; inline void Phi_Sieve () { phi [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , phi [ i ] = i -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) phi [ i * P [ j ]] = phi [ i ] * phi [ P [ j ]]; else { phi [ i * P [ j ]] = phi [ i ] * P [ j ]; break ;} } } return ; } int mu [ N + 10 ]; inline void Mu_Sieve () { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , mu [ i ] = -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) mu [ i * P [ j ]] =- mu [ i ]; else { mu [ i * P [ j ]] = 0 ; break ;} } } return ; } int d [ N + 10 ], num [ N + 10 ]; inline void D_Sieve () { d [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , d [ i ] = 2 , num [ i ] = 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) num [ i * P [ j ]] = 1 , d [ i * P [ j ]] = d [ i ] * 2 ; else { num [ i * P [ j ]] = num [ i ] + 1 , d [ i * P [ j ]] = d [ i ] / num [ i * P [ j ]] * ( num [ i * P [ j ]] + 1 ); break ;} } } return ; } int f [ N + 10 ], g [ N + 10 ]; inline void Sum_Sieve () { f [ 1 ] = g [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , f [ i ] = g [ i ] = i + 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) f [ i * P [ j ]] = f [ i ] * f [ P [ j ]], g [ i * P [ j ]] = P [ j ] + 1 ; else { f [ i * P [ j ]] = f [ i ] / g [ i ] * ( g [ i ] * P [ j ] + 1 ), g [ i * P [ j ]] = g [ i ] * P [ j ] + 1 ; break ;} } } return ; } }","title":"\u7b5b\u6cd5"},{"location":"package/BigNum/","text":"\u8f93\u5165\u8f93\u51fa\u7528 .bin() \u548c .bout() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 namespace BigNum { static const int Base = 100000000 ; static const int Dig = 8 ; struct bignum { short fh ; vector < int > V ; bignum () { * this = 0 ;} bignum ( int num ) { * this = num ;} inline int size () { return V . size ();} inline int back () { return V . back ();} inline void resize ( int N ) { return V . resize ( N ), void ();} inline void clear () { return V . clear (), void ();} inline void bin () { string s ; cin >> s , * this = s ;} inline void bout () { if ( fh ) putchar ( '-' ); write ( V . back (), '~' ); for ( int i = (( int ) V . size ()) -2 ; ~ i ; -- i ) { char buf [ 20 ]; sprintf ( buf , \"%08lld\" , V [ i ]); for ( int j = 0 ; j < (( int ) strlen ( buf )); ++ j ) putchar ( buf [ j ]); } } inline int & operator [] ( int i ) { return V [ i ];} inline bignum operator = ( string s ) { V . clear (), fh = s [ 0 ] == '-' ? 1 : 0 ; string ss = \"\" ; for ( int i = fh ; i < (( int ) s . size ()); ++ i ) ss += s [ i ]; int len = ( ss . size () -1 ) / Dig + 1 ; for ( int i = 0 , x ; i < len ; ++ i ) { int end = ss . size () - i * Dig , start = max ( 0l l , end - Dig ); sscanf ( ss . substr ( start , end - start ). c_str (), \"%lld\" , & x ); V . eb ( x ); } return * this ; } inline bignum operator = ( int T ) { V . clear (), fh = T < 0 ? 1 : 0 ; T = abs ( T ); do this -> V . eb ( T % Base ), T /= Base ; while ( T > 0 ); return * this ;} inline friend bool operator == ( bignum a , bignum b ) { if ( a . size () != b . size () || a . fh != b . fh ) return 0 ; for ( int i = 0 ; i < (( int ) a . size ()); ++ i ) if ( a [ i ] != b [ i ]) return 0 ; return 1 ; } inline friend bool operator > ( bignum a , bignum b ) { if ( a . fh < b . fh ) return 1 ; if ( a . size () > b . size ()) return 1 ; if ( a . size () < b . size ()) return 0 ; for ( int i = (( int ) a . size ()) -1 ; ~ i ; -- i ) { if ( a [ i ] > b [ i ]) return 1 ; if ( a [ i ] < b [ i ]) return 0 ; } return 0 ; } inline friend bool operator < ( bignum a , bignum b ) { if ( a . fh > b . fh ) return 0 ; if ( a . size () > b . size ()) return 0 ; if ( a . size () < b . size ()) return 1 ; for ( int i = (( int ) a . size ()) -1 ; ~ i ; -- i ) { if ( a [ i ] > b [ i ]) return 0 ; if ( a [ i ] < b [ i ]) return 1 ; } return 0 ; } inline friend bool operator >= ( bignum a , bignum b ) { return a == b || a > b ;} inline friend bool operator <= ( bignum a , bignum b ) { return a == b || a < b ;} inline friend bignum operator + ( bignum a , bignum b ) { if ( a . fh != b . fh ) return a . fh ? ( a . fh ^= 1 , b - a ) : ( b . fh ^= 1 , a - b ); bignum c ; c . clear (), c . fh = a . fh ; for ( int i = 0 , carry = 0 ;; ++ i ) { if ( ! carry && i >= a . size () && i >= b . size ()) break ; int X = carry ; X += ( i < a . size () ? a [ i ] : 0 ) + ( i < b . size () ? b [ i ] : 0 ); c . V . eb ( X % Base ), carry = X / Base ; } return c ; } inline friend bignum operator - ( bignum a , bignum b ) { if ( b . fh ) return b . fh ^= 1 , a + b ; bignum c ; int flag = 0 ; if ( a < b ) flag = 1 , Swp ( a , b ); c = a , c . fh = flag ; for ( int i = 0 , tmp ; i < c . size (); ++ i ) { if ( i >= b . size ()) tmp = 0 ; else tmp = b [ i ]; if ( c [ i ] < tmp ) c [ i + 1 ] -= 1 , c [ i ] += Base ; c [ i ] -= tmp ; } while ( c . back () == 0 && c . size () > 1 ) c . V . pb (); return c ; } inline friend bignum operator * ( bignum a , bignum b ) { bignum c ; c . resize ( a . size () + b . size ()), c . fh = ( a . fh != b . fh ); for ( int i = 0 ; i < a . size (); ++ i ) for ( int j = 0 ; j < b . size (); ++ j ) c [ i + j ] += a [ i ] * b [ j ]; for ( int i = 0 ; i < c . size () -1 ; ++ i ) c [ i + 1 ] += c [ i ] / Base , c [ i ] %= Base ; while ( c . back () == 0 && c . size () > 1 ) c . V . pb (); return c ; } inline friend bignum operator ^ ( bignum a , int b ) { bignum res = a ; while ( b ) { if ( b & 1 ) res *= a ; a *= a ; b >>= 1 ;} return res ; } inline bignum operator += ( const bignum & T ) { * this =* this + T ; return * this ;} inline bignum operator -= ( const bignum & T ) { * this =* this - T ; return * this ;} inline bignum operator *= ( const bignum & T ) { * this =* this * T ; return * this ;} inline bignum operator ^= ( const int & T ) { * this =* this ^ T ; return * this ;} }; bignum ZERO ; int Pow [ MAX ], flag ; inline void DivInit () { ZERO = \"0\" ; Pow [ 0 ] = 1 ; for ( int i = 1 ; i <= __lg ( Base ); ++ i ) Pow [ i ] = Pow [ i -1 ] * 2 ; flag = 1 ; } inline bignum trans ( bignum a , int x ) { bignum b ; b . resize ( a . size () + x ); for ( int i = 0 ; i < a . size (); ++ i ) b [ i + x ] = a [ i ]; return b ; } inline pair < bignum , bignum > Divide ( bignum a , bignum b ) { if ( ! flag ) DivInit (); if ( a < b ) return mp ( ZERO , a ); bignum c , d ; c . resize ( a . size () - b . size () + 1 ), d = a ; for ( int i = c . size () -1 ; ~ i ; -- i ) { bignum t ; t = trans ( b , i ); for ( int j = __lg ( Base ); ~ j ; -- j ) if ( d >= t * bignum ( Pow [ j ])) c . V [ i ] += Pow [ j ], d -= t * bignum ( Pow [ j ]); } while ( c . back () == 0 && c . size () > 1 ) c . V . pb (); return mp ( c , d ); } }","title":"BigNum"},{"location":"package/Frac/","text":"\u5b9a\u4e49\u5373\u4e3a frac a(nume,deno,sign) \uff0c\u542b\u4e49\u5206\u522b\u4e3a\u5206\u5b50\u3001\u5206\u6bcd\u3001\u7b26\u53f7\uff08 \\(-1\\) \u4e3a\u8d1f\uff0c \\(1\\) \u4e3a\u6b63\uff09\u3002 Inv(a) \u4e3a\u6c42 \\(a\\) \u7684\u9006\u5143\u3002 pout(a) \u4e3a\u5e26\u6362\u884c\u7684\u8f93\u51fa\u5206\u6570 \\(a\\) \uff0c\u53ef\u4ee5\u81ea\u884c\u6839\u636e\u9700\u6c42\u8c03\u6574\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 namespace Frac { inline int Gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } inline int Lcm ( int a , int b ) { return a * b / Gcd ( a , b ); } void Exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); Exgcd ( b , a % b , y , x ), y -= x * ( a / b ); } void Abs ( int & a ) { return a = a < 0 ?- a : a , void (); } struct frac { int nume , deno , sign ; frac ( int Nume = 0 , int Deno = 0 , int Sign = 0 ) : nume ( Nume ), deno ( Deno ), sign ( Sign ) {} inline frac operator = ( const frac & T ) { this -> nume = T . nume , this -> deno = T . deno , this -> sign = T . sign ; return * this ;} inline void Reduce () { int tmp = Gcd ( nume , deno ); nume /= tmp , deno /= tmp ; } inline frac operator - () { return frac ( nume , deno , - sign ); } inline friend frac operator + ( frac a , frac b ) { frac res ; res . deno = Lcm ( a . deno , b . deno ); if ( a . sign == b . sign ) res . sign = a . sign , res . nume = res . deno / a . deno * a . nume + res . deno / b . deno * b . nume ; else if ( b . sign == -1 ) res . nume = res . deno / a . deno * a . nume - res . deno / b . deno * b . nume , res . nume < 0 ? res . sign = -1 : res . sign = 1 , Abs ( res . nume ); else if ( a . sign == -1 ) res . nume = res . deno / b . deno * b . nume - res . deno / a . deno * a . nume , res . nume < 0 ? res . sign = -1 : res . sign = 1 , Abs ( res . nume ); res . Reduce (); return res ; } inline friend frac operator - ( frac a , frac b ) { return a + ( - b );} inline friend frac operator * ( frac a , frac b ) { frac res ; res . nume = a . nume * b . nume , res . deno = a . deno * b . deno , res . sign = a . sign * b . sign ; res . Reduce (); return res ; } inline friend frac operator / ( frac a , frac b ) { return a * ( frac ( b . deno , b . nume , b . sign ));} inline friend bool operator == ( frac a , frac b ) { return a . nume == b . nume && a . deno == b . deno && a . sign == b . sign ;} inline friend bool operator > ( frac a , frac b ) { if ( a . sign != b . sign ) return a . sign > b . sign ; int tmp = Lcm ( a . deno , b . deno ); return tmp / a . deno * a . nume > tmp / b . deno * b . nume ; } inline friend bool operator < ( frac a , frac b ) { if ( a . sign != b . sign ) return a . sign < b . sign ; int tmp = Lcm ( a . deno , b . deno ); return tmp / a . deno * a . nume < tmp / b . deno * b . nume ; } inline friend bool operator >= ( frac a , frac b ) { return a > b || a == b ;} inline friend bool operator <= ( frac a , frac b ) { return a < b || a == b ;} inline frac operator += ( const frac & T ) { * this =* this + T ; return * this ;} inline frac operator -= ( const frac & T ) { * this =* this - T ; return * this ;} inline frac operator *= ( const frac & T ) { * this =* this * T ; return * this ;} inline frac operator /= ( const frac & T ) { * this =* this / T ; return * this ;} }; inline int Inv ( frac a ) { a . nume %= a . deno ; if ( a . sign == -1 ) a . nume = a . deno - a . nume ; int X = 0 , Y = 0 ; Exgcd ( a . nume , a . deno , X , Y ); return ( X % a . deno + a . deno ) % a . deno ; } inline void fout ( frac a ) { if ( a . deno == 1 ) write ( a . sign * a . nume , '\\n' ); else write ( a . sign * a . nume , '/' ), write ( a . deno , '\\n' ); } }","title":"Frac"},{"location":"package/Geometry/","text":"","title":"Geometry"},{"location":"package/Matrix/","text":"\u4f7f\u7528\u7684\u65f6\u5019\u66f4\u6539\u77e9\u9635\u7c7b\u578b T=... \u5373\u53ef\u3002 Gauss \u6d88\u5143\u8fd4\u56de\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u7b2c\u4e8c\u7ef4\u4e3a\u7c7b\u578b\uff0c \\(1\\) \u4e3a\u552f\u4e00\u89e3\uff0c \\(0\\) \u4e3a\u65e0\u6570\u89e3\uff0c \\(-1\\) \u4e3a\u65e0\u89e3\u3002 \u77e9\u9635\u6c42\u9006\u642d\u914d ModInt \u4f7f\u7528\uff0c\u8fd4\u56de\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u7b2c\u4e8c\u7ef4\u4e3a\u7c7b\u578b\uff0c \\(1\\) \u4e3a\u6709\u9006\uff0c \\(0\\) \u4e3a\u65e0\u9006\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 namespace Matrix { static const double eps = 1e-9 ; template < typename T = ModInt < Mod >> struct matrix { vector < vector < T >> a ; inline matrix ( int n = 0 ) : a ( n ) {} inline matrix ( const vector < vector < T >> & b ) : a ( b ) {} inline matrix ( const matrix & b ) { a = b . a ;} inline vector < T > & operator [] ( int i ) { return a [ i ];} inline matrix operator = ( const matrix & b ) { this -> a = b . a ; return * this ;} inline int size () { return a . size ();} inline void resize ( int n ) { a . resize ( n , vector < T > ( n ));} inline friend matrix operator + ( matrix a , matrix b ) { int N = a . size (); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) a [ i ][ j ] += b [ i ][ j ]; return a ; } inline friend matrix operator - ( matrix a , matrix b ) { int N = a . size (); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) a [ i ][ j ] -= b [ i ][ j ]; return a ; } template < typename W > inline friend matrix operator * ( matrix a , W b ) { int N = a . size (); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) a [ i ][ j ] = ( T )( a [ i ][ j ] * b ); return a ; } inline friend matrix operator * ( matrix a , matrix b ) { int N = a . size (); matrix res ; res . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) for ( int k = 0 ; k < N ; ++ k ) res [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; return res ; } inline friend matrix operator ^ ( matrix a , int b ) { int N = a . size (); matrix res , bas ; res . resize ( N ), bas . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) bas [ i ][ j ] = a [ i ][ j ], res [ i ][ i ] = (( T ) 1 ); while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ; } inline pair < vector < T > , int > Gauss ( vector < T > coef ) { int N = a . size (), x = 0 , y = 0 ; for (; y < N ; ++ y ) { int now = x ; T mix = fabs ( a [ x ][ y ]); for ( int i = x + 1 ; i < N ; ++ i ) if ( fabs ( a [ i ][ y ]) - mix > eps ) now = i , mix = fabs ( a [ i ][ y ]); if ( mix < eps ) continue ; swap ( coef [ x ], coef [ now ]), swap ( a [ x ], a [ now ]); for ( int i = 0 ; i < N ; ++ i ) { if ( i == x ) continue ; for ( int j = y + 1 ; j < N ; ++ j ) a [ i ][ j ] -= a [ i ][ y ] / a [ x ][ y ] * a [ x ][ j ]; coef [ i ] -= a [ i ][ y ] / a [ x ][ y ] * coef [ x ]; } ++ x ; } -- x ; vector < T > ZERO ( 0 ), ans ( N ); if ( x < N -1 ) { for ( int i = x + 1 ; i < N ; ++ i ) if ( fabs ( coef [ i ]) > eps ) return make_pair ( ZERO , -1 ); return make_pair ( ZERO , 0 ); } for ( int i = 0 ; i < N ; ++ i ) { ans [ i ] = coef [ i ] / a [ i ][ i ]; if ( fabs ( ans [ i ]) < eps ) ans [ i ] = 0 ; } return make_pair ( ans , 1 ); } inline pair < matrix , int > Inv () { int N = a . size (); matrix A ( a ), B , ZERO ( 0 ); B . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) B [ i ][ i ] = 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( ! A [ i ][ i ]) for ( int j = i + 1 ; j < N ; ++ j ) if ( A [ j ][ i ] != 0 ) { swap ( A [ i ], A [ j ]), swap ( B [ i ], B [ j ]); break ;} if ( ! A [ i ][ i ]) return make_pair ( ZERO , 0 ); T inv = 1 / A [ i ][ i ]; for ( int j = 0 ; j < N ; ++ j ) A [ i ][ j ] *= inv , B [ i ][ j ] *= inv ; for ( int j = i + 1 ; j < N ; ++ j ) { T ret =- A [ j ][ i ]; for ( int k = 0 ; k < N ; ++ k ) A [ j ][ k ] += ret * A [ i ][ k ], B [ j ][ k ] += ret * B [ i ][ k ]; } } for ( int i = N -1 ; ~ i ; -- i ) for ( int j = i + 1 ; j < N ; ++ j ) { T ret =- A [ i ][ j ]; for ( int k = 0 ; k < N ; ++ k ) A [ i ][ k ] += ret * A [ j ][ k ], B [ i ][ k ] += ret * B [ j ][ k ]; } return make_pair ( B , 1 ); } }; }","title":"Matrix"},{"location":"package/ModNum/","text":"\u666e\u901a\u60c5\u51b5\u4e0b\u66f4\u63a8\u8350\u4f7f\u7528\u5e38\u7528\u7f3a\u7701\u6e90\u91cc\u7684 MTool \uff0c\u66f4\u52a0\u65b9\u4fbf\u597d\u7528\uff0c\u53ea\u9700\u8981\u66f4\u6539 Mod \u7684\u503c\u3002 \u5b9a\u6a21\u6570\u7248\u672c \u00b6 \u53ea\u9700\u8981\u4fee\u6539 const \u7684\u90a3\u4e2a \\(Mod\\) \u7684\u503c\u5c31\u884c\uff0c\u8f93\u5165\u8f93\u51fa\u9700\u8981\u52a0\u4e0a \\(.x\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 namespace MInt { static const int Mod = 998244353 ; template < const int Mod > struct ModInt { int x ; ModInt ( int X = 0 ) : x ( X ) {} inline ModInt operator = ( int & T ) { * this . x = T ; return * this ;} inline ModInt operator = ( const ModInt & T ) { this -> x = T . x ; return * this ;} inline friend ModInt operator + ( ModInt a , ModInt b ) { return a . x + b . x >= Mod ? a . x + b . x - Mod : a . x + b . x ;} inline friend ModInt operator - ( ModInt a , ModInt b ) { return a . x - b . x < 0 ? a . x - b . x + Mod : a . x - b . x ;} inline friend ModInt operator * ( ModInt a , ModInt b ) { return a . x * b . x % Mod ;} inline friend ModInt operator ^ ( ModInt a , int b ) { ModInt res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ;} inline friend ModInt operator / ( ModInt a , ModInt b ) { return a * ( b ^ ( Mod -2 ));} inline ModInt operator += ( const ModInt & T ) { * this =* this + T ; return * this ;} inline ModInt operator -= ( const ModInt & T ) { * this =* this - T ; return * this ;} inline ModInt operator *= ( const ModInt & T ) { * this =* this * T ; return * this ;} inline ModInt operator ^= ( const ModInt & T ) { * this =* this ^ T ; return * this ;} inline ModInt operator /= ( const ModInt & T ) { * this =* this / T ; return * this ;} template < typename T > inline friend ModInt operator + ( ModInt a , T x ) { return a + ModInt ( x );} template < typename T > inline friend ModInt operator - ( ModInt a , T x ) { return a - ModInt ( x );} template < typename T > inline friend ModInt operator * ( ModInt a , T x ) { return a * ModInt ( x );} template < typename T > inline friend ModInt operator / ( ModInt a , T x ) { return a / ModInt ( x );} inline friend bool operator == ( ModInt a , ModInt b ) { return a . x == b . x ;} inline friend bool operator != ( ModInt a , ModInt b ) { return a . x != b . x ;} inline friend bool operator > ( ModInt a , ModInt b ) { return a . x > b . x ;} inline friend bool operator < ( ModInt a , ModInt b ) { return a . x < b . x ;} inline friend bool operator >= ( ModInt a , ModInt b ) { return a > b || a == b ;} inline friend bool operator <= ( ModInt a , ModInt b ) { return a < b || a == b ;} template < typename T > inline friend bool operator == ( ModInt a , T b ) { return a == ModInt ( b );} template < typename T > inline friend bool operator != ( ModInt a , T b ) { return a != ModInt ( b );} template < typename T > inline friend bool operator > ( ModInt a , T b ) { return a > ModInt ( b );} template < typename T > inline friend bool operator < ( ModInt a , T b ) { return a < ModInt ( b );} template < typename T > inline friend bool operator >= ( ModInt a , T b ) { return a >= ModInt ( b );} template < typename T > inline friend bool operator <= ( ModInt a , T b ) { return a <= ModInt ( b );} inline bool operator ! () { return ! x ;} inline ModInt operator - () { return x ? Mod - x : 0 ;} }; } \u53ef\u53d8\u6a21\u6570 \u00b6 \u66f4\u6539\u6a21\u6570\u8c03\u7528 ChangeMod \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 struct ModNum { #define TA template<typename T,typename... Args> #define TT template<typename T> struct fastmod { using u128 = __uint128_t ; using u64 = uint64_t ; using u32 = signed ; u32 f , l ; u64 m , d ; fastmod ( u64 D = 998244353 ) : d ( D ) { const u128 ONE = 1 ; l = 64 - __builtin_clzll ( d -1 ); u128 M = (( ONE << ( 64 + l )) + ( ONE << l )) / d ; if ( M < ( ONE << 64 )) f = 1 , m = M ; else f = 0 , m = M - ( ONE << 64 ); } inline friend u64 operator / ( u64 x , const fastmod & y ) { if ( y . f ) return u128 ( x ) * y . m >> 64 >> y . l ; else return ((( x - ( u128 ( x ) * y . m >> 64 )) >> 1 ) + ( u128 ( x ) * y . m >> 64 )) >> ( y . l -1 ); } inline friend u64 operator % ( u64 x , const fastmod & y ) { return x - x / y * y . d ; } inline friend u64 operator + ( u64 x , const fastmod & y ) { return x + y . d ;} inline friend u64 operator - ( u64 x , const fastmod & y ) { return x - y . d ;} inline friend bool operator == ( u64 x , const fastmod & y ) { return x == y . d ;} inline friend bool operator > ( u64 x , const fastmod & y ) { return x > y . d ;} inline friend bool operator < ( u64 x , const fastmod & y ) { return x < y . d ;} inline friend bool operator >= ( u64 x , const fastmod & y ) { return x > y . d || x == y . d ;} inline friend bool operator <= ( u64 x , const fastmod & y ) { return x < y . d || x == y . d ;} }; fastmod Mod ; inline void ChangeMod ( int MOD ){ Mod = MOD ;} TT inline void Madd ( T & a , T b ) { a = a + b >= Mod ? a + b - Mod : a + b ;} TT inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} TT inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} TT inline void Mmod ( T & a ) { a = ( a % Mod + Mod ) % Mod ;} TT inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} TT inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} TT inline T Cmul ( T a , T b ) { return a * b % Mod ;} TT inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} TA inline void Madd ( T & a , T b , Args ... args ) { Madd ( a , Cadd ( b , args ...));} TA inline void Mdel ( T & a , T b , Args ... args ) { Mdel ( a , Cadd ( b , args ...));} TA inline void Mmul ( T & a , T b , Args ... args ) { Mmul ( a , Cmul ( b , args ...));} TA inline T Cadd ( T a , T b , Args ... args ) { return Cadd ( Cadd ( a , b ), args ...);} TA inline T Cdel ( T a , T b , Args ... args ) { return Cdel ( Cdel ( a , b ), args ...);} TA inline T Cmul ( T a , T b , Args ... args ) { return Cmul ( Cmul ( a , b ), args ...);} TT inline T qpow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} TT inline T qmul ( T a , T b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} TT inline T spow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} TT inline T Ginv ( T x ) { return qpow ( x ,( T )( Mod . d -2 ));} #undef TT #undef TA };","title":"ModNum"},{"location":"package/ModNum/#_1","text":"\u53ea\u9700\u8981\u4fee\u6539 const \u7684\u90a3\u4e2a \\(Mod\\) \u7684\u503c\u5c31\u884c\uff0c\u8f93\u5165\u8f93\u51fa\u9700\u8981\u52a0\u4e0a \\(.x\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 namespace MInt { static const int Mod = 998244353 ; template < const int Mod > struct ModInt { int x ; ModInt ( int X = 0 ) : x ( X ) {} inline ModInt operator = ( int & T ) { * this . x = T ; return * this ;} inline ModInt operator = ( const ModInt & T ) { this -> x = T . x ; return * this ;} inline friend ModInt operator + ( ModInt a , ModInt b ) { return a . x + b . x >= Mod ? a . x + b . x - Mod : a . x + b . x ;} inline friend ModInt operator - ( ModInt a , ModInt b ) { return a . x - b . x < 0 ? a . x - b . x + Mod : a . x - b . x ;} inline friend ModInt operator * ( ModInt a , ModInt b ) { return a . x * b . x % Mod ;} inline friend ModInt operator ^ ( ModInt a , int b ) { ModInt res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ;} inline friend ModInt operator / ( ModInt a , ModInt b ) { return a * ( b ^ ( Mod -2 ));} inline ModInt operator += ( const ModInt & T ) { * this =* this + T ; return * this ;} inline ModInt operator -= ( const ModInt & T ) { * this =* this - T ; return * this ;} inline ModInt operator *= ( const ModInt & T ) { * this =* this * T ; return * this ;} inline ModInt operator ^= ( const ModInt & T ) { * this =* this ^ T ; return * this ;} inline ModInt operator /= ( const ModInt & T ) { * this =* this / T ; return * this ;} template < typename T > inline friend ModInt operator + ( ModInt a , T x ) { return a + ModInt ( x );} template < typename T > inline friend ModInt operator - ( ModInt a , T x ) { return a - ModInt ( x );} template < typename T > inline friend ModInt operator * ( ModInt a , T x ) { return a * ModInt ( x );} template < typename T > inline friend ModInt operator / ( ModInt a , T x ) { return a / ModInt ( x );} inline friend bool operator == ( ModInt a , ModInt b ) { return a . x == b . x ;} inline friend bool operator != ( ModInt a , ModInt b ) { return a . x != b . x ;} inline friend bool operator > ( ModInt a , ModInt b ) { return a . x > b . x ;} inline friend bool operator < ( ModInt a , ModInt b ) { return a . x < b . x ;} inline friend bool operator >= ( ModInt a , ModInt b ) { return a > b || a == b ;} inline friend bool operator <= ( ModInt a , ModInt b ) { return a < b || a == b ;} template < typename T > inline friend bool operator == ( ModInt a , T b ) { return a == ModInt ( b );} template < typename T > inline friend bool operator != ( ModInt a , T b ) { return a != ModInt ( b );} template < typename T > inline friend bool operator > ( ModInt a , T b ) { return a > ModInt ( b );} template < typename T > inline friend bool operator < ( ModInt a , T b ) { return a < ModInt ( b );} template < typename T > inline friend bool operator >= ( ModInt a , T b ) { return a >= ModInt ( b );} template < typename T > inline friend bool operator <= ( ModInt a , T b ) { return a <= ModInt ( b );} inline bool operator ! () { return ! x ;} inline ModInt operator - () { return x ? Mod - x : 0 ;} }; }","title":"\u5b9a\u6a21\u6570\u7248\u672c"},{"location":"package/ModNum/#_2","text":"\u66f4\u6539\u6a21\u6570\u8c03\u7528 ChangeMod \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 struct ModNum { #define TA template<typename T,typename... Args> #define TT template<typename T> struct fastmod { using u128 = __uint128_t ; using u64 = uint64_t ; using u32 = signed ; u32 f , l ; u64 m , d ; fastmod ( u64 D = 998244353 ) : d ( D ) { const u128 ONE = 1 ; l = 64 - __builtin_clzll ( d -1 ); u128 M = (( ONE << ( 64 + l )) + ( ONE << l )) / d ; if ( M < ( ONE << 64 )) f = 1 , m = M ; else f = 0 , m = M - ( ONE << 64 ); } inline friend u64 operator / ( u64 x , const fastmod & y ) { if ( y . f ) return u128 ( x ) * y . m >> 64 >> y . l ; else return ((( x - ( u128 ( x ) * y . m >> 64 )) >> 1 ) + ( u128 ( x ) * y . m >> 64 )) >> ( y . l -1 ); } inline friend u64 operator % ( u64 x , const fastmod & y ) { return x - x / y * y . d ; } inline friend u64 operator + ( u64 x , const fastmod & y ) { return x + y . d ;} inline friend u64 operator - ( u64 x , const fastmod & y ) { return x - y . d ;} inline friend bool operator == ( u64 x , const fastmod & y ) { return x == y . d ;} inline friend bool operator > ( u64 x , const fastmod & y ) { return x > y . d ;} inline friend bool operator < ( u64 x , const fastmod & y ) { return x < y . d ;} inline friend bool operator >= ( u64 x , const fastmod & y ) { return x > y . d || x == y . d ;} inline friend bool operator <= ( u64 x , const fastmod & y ) { return x < y . d || x == y . d ;} }; fastmod Mod ; inline void ChangeMod ( int MOD ){ Mod = MOD ;} TT inline void Madd ( T & a , T b ) { a = a + b >= Mod ? a + b - Mod : a + b ;} TT inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} TT inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} TT inline void Mmod ( T & a ) { a = ( a % Mod + Mod ) % Mod ;} TT inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} TT inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} TT inline T Cmul ( T a , T b ) { return a * b % Mod ;} TT inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} TA inline void Madd ( T & a , T b , Args ... args ) { Madd ( a , Cadd ( b , args ...));} TA inline void Mdel ( T & a , T b , Args ... args ) { Mdel ( a , Cadd ( b , args ...));} TA inline void Mmul ( T & a , T b , Args ... args ) { Mmul ( a , Cmul ( b , args ...));} TA inline T Cadd ( T a , T b , Args ... args ) { return Cadd ( Cadd ( a , b ), args ...);} TA inline T Cdel ( T a , T b , Args ... args ) { return Cdel ( Cdel ( a , b ), args ...);} TA inline T Cmul ( T a , T b , Args ... args ) { return Cmul ( Cmul ( a , b ), args ...);} TT inline T qpow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} TT inline T qmul ( T a , T b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} TT inline T spow ( T a , T b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} TT inline T Ginv ( T x ) { return qpow ( x ,( T )( Mod . d -2 ));} #undef TT #undef TA };","title":"\u53ef\u53d8\u6a21\u6570"},{"location":"package/Poly/","text":"\u4f7f\u7528\u6ce8\u610f\u4e8b\u9879\uff1a \u9700\u8981\u642d\u914d ModNum \u91cc\u9762\u7684 MInt \u4f7f\u7528\u3002 \u8981\u5148\u8fd0\u884c Prework \uff0c\u53c2\u6570\u662f\u591a\u9879\u5f0f\u6700\u9ad8\u5ea6\u6570\uff0c\u6709\u65f6\u5019\u7b54\u6848\u4e0d\u5bf9\u53ef\u80fd\u662f\u521d\u59cb\u5316\u5c0f\u4e86\uff0c\u5f00\u5927\u70b9\u8bd5\u8bd5\u3002 NTT \u7684\u6a21\u6570\u4e0d\u540c\u9700\u8981\u66f4\u6539 Prework \u7684\u53c2\u6570\uff0c\u82e5\u6a21\u6570\u4e3a \\(r \\times 2^k + 1\\) \uff0c\u90a3\u4e48 \\(GT\\) \u6539\u4e3a \\(k - 2\\) \uff0c \\(GR\\) \u6539\u4e3a \\(g^r\\) \uff0c\u5176\u4e2d \\(g\\) \u4e3a\u6a21\u6570\u7684\u539f\u6839\u3002 \u8d4b\u503c\u7528 .pin \uff0c\u8f93\u51fa\u7528 .pout \u3002 \u591a\u9879\u5f0f\u5c01\u88c5\u4e86\u4e00\u4e2a poly \u7c7b\uff0c\u91cc\u5934\u662f\u81ea\u53d6\u6a21\u7684 ModInt \u7c7b\uff0c\u6a21\u6570\u4e0d\u540c\u9700\u8981\u4fee\u6539 Mod \u3002 \u5404\u51fd\u6570\u610f\u4e49\uff1a \u4e58\u6cd5\u76f4\u63a5\u7528 * \uff1b\u9664\u6cd5\u5982\u679c\u540c\u65f6\u6c42\u5546\u548c\u4f59\u6570\u7528 Div \uff0c\u8fd4\u56de\u4e00\u4e2a poly \u4e8c\u5143\u7ec4\uff0c\u5426\u5219\u76f4\u63a5\u7528 / \u6216\u8005 % \u5373\u53ef\u3002 Inv \u4e3a\u6c42\u9006\uff0c Dvt \u4e3a\u6c42\u5bfc\uff0c Igt \u4e3a\u79ef\u5206\u3002 Ln \u4e3a\u6c42\u5bf9\u6570\uff0c Exp \u4e3a\u6c42\u6307\u6570\u3002 Sqr \u4e3a\u5f00\u65b9\uff0c\u4f20\u53c2 \\(tp = 1\\) \u8fd4\u56de \\(\\sqrt{a}\\) \uff0c \\(tp = -1\\) \u8fd4\u56de \\(\\dfrac{1}{\\sqrt{a}}\\) \u3002 Pow \u4e3a\u5feb\u901f\u5e42\uff0c\u7b2c\u4e00\u4e2a\u975e \\(0\\) \u9879\u4e3a\u5e38\u6570\uff0c\u4f20\u5e42\u6b21\u76f4\u63a5\u4f20\u6570\u503c\uff0c\u5426\u5219\u4f20\u8fdb\u53bb\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002 \u4e09\u89d2\u51fd\u6570\u548c\u53cd\u4e09\u89d2\u51fd\u6570\u540c\u51fd\u6570\u540d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 namespace Poly { static const int MAX = 4000010 ; static const double PI = acos ( -1 ); static const ModInt < Mod > gn = 332748118 , gni = 3 , ZERO = 0 , ONE = 1 ; namespace Quadraticresidue { ModInt < Mod > I ; struct Complex { ModInt < Mod > x , y ; Complex ( ModInt < Mod > X = 0 , ModInt < Mod > Y = 0 ) : x ( X ), y ( Y ) {} inline friend bool operator == ( Complex a , Complex b ) { return a . x == b . x && a . y == b . y ;} inline friend Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x + a . y * b . y * I , a . x * b . y + a . y * b . x );} }; inline Complex qpow ( Complex a , int b ) { Complex res ( 1 , 0 ); while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b >>= 1 ;} return res ;} inline ModInt < Mod > random ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return ModInt < Mod > ( range ( sd )); } inline pair < ModInt < Mod > , ModInt < Mod >> Cipolla ( ModInt < Mod > n ) { if ( ! n ) return make_pair ( 0 , 0 ); ModInt < Mod > x , x1 , x2 ; do x = random ( 1 , Mod -1 ); while ((( x * x + Mod - n ) ^ (( Mod -1 ) >> 1 )) == ONE ); I = x * x + Mod - n , x1 = qpow ( Complex ( x , 1 ),( Mod + 1 ) >> 1 ). x , x2 = Mod - x1 ; return make_pair ( min ( x1 , x2 ), max ( x1 , x2 )); } } using namespace Quadraticresidue ; struct poly { vector < ModInt < Mod >> a ; inline ModInt < Mod > & operator [] ( int i ) { return a [ i ];} inline poly operator = ( const poly & T ) { this -> a = T . a ; return * this ;} inline int size () { return a . size ();} inline void resize ( int N ) { return a . resize ( N ), void ();} inline void reverse () { return std :: reverse ( a . begin (), a . end ());} inline void pin ( int x ) { return a . emplace_back ( ModInt < Mod > ( x )), void ();} inline void pout () { for ( auto it : a ) write ( it . x , ' ' );} }; inline int Sup ( int N ) { int K = 1 ; while ( K < N ) K <<= 1 ; return K ;} static const int GT = 21 , GR = 31 ; ModInt < Mod > omega [ MAX ]; poly zero , one ; inline void Prework ( int N ) { zero . a . emplace_back ( ZERO ), one . a . emplace_back ( ONE ); int K = 1 ; while (( 1 << K ) < N ) ++ K ; K = min ( K -1 , 21l l ); omega [ 0 ] = 1 , omega [ 1 << K ] = ( ModInt < Mod > ( GR )) ^ ( 1 << ( GT - K )); for ( int i = K ; i >= 1 ; -- i ) omega [ 1 << ( i -1 )] = omega [ 1 << i ] * omega [ 1 << i ]; for ( int i = 1 ; i < ( 1 << K ); ++ i ) omega [ i ] = omega [ i & ( i -1 )] * omega [ i & ( - i )]; } inline void NTT ( poly & F , int typ ) { ModInt < Mod > U , V ; int N = F . size (); if ( typ == 1 ) { for ( int mid = N >> 1 ; mid >= 1 ; mid >>= 1 ) for ( int i = 0 , k = 0 ; i < N ; i += mid << 1 , ++ k ) for ( int j = 0 ; j < mid ; ++ j ) U = F [ i + j ], V = F [ i + j + mid ] * omega [ k ], F [ i + j ] = U + V , F [ i + j + mid ] = U - V ; } if ( typ == -1 ) { for ( int mid = 1 ; mid < N ; mid <<= 1 ) for ( int i = 0 , k = 0 ; i < N ; i += mid << 1 , ++ k ) for ( int j = 0 ; j < mid ; ++ j ) U = F [ i + j ], V = F [ i + j + mid ], F [ i + j ] = U + V , F [ i + j + mid ] = ( U - V ) * omega [ k ]; ModInt < Mod > Ninv = ONE / N ; for ( int i = 0 ; i < N ; ++ i ) F [ i ] *= Ninv ; reverse ( F . a . begin () + 1 , F . a . end ()); } } inline poly operator * ( poly a , ModInt < Mod > b ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] *= b ; return a ;} inline poly operator / ( poly a , ModInt < Mod > b ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] /= b ; return a ;} inline poly operator - ( poly a ) { for ( int i = 0 ; i < a . size (); ++ i ) a [ i ] =- a [ i ]; return a ;} inline poly operator + ( poly a , poly b ) { int N = max ( a . size (), b . size ()); a . resize ( N ), b . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] += b [ i ]; return a ; } inline poly operator - ( poly a , poly b ) { int N = max ( a . size (), b . size ()); a . resize ( N ), b . resize ( N ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] -= b [ i ]; return a ; } inline poly operator * ( poly a , poly b ) { int K = a . size () + b . size () -1 , N = Sup ( K ); a . resize ( N ), b . resize ( N ); NTT ( a , 1 ), NTT ( b , 1 ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] *= b [ i ]; NTT ( a , -1 ); a . resize ( K ); return a ; } inline poly operator >> ( poly a , int d ) { int N = a . size (); poly b ; b . resize ( N + d ); for ( int i = 0 ; i < N ; ++ i ) b [ i + d ] = a [ i ]; return b ; } inline poly operator << ( poly a , int d ) { int N = a . size (); if ( N <= d ) return zero ; poly b ; b . resize ( N - d ); for ( int i = 0 ; i < N - d ; ++ i ) b [ i ] = a [ i + d ]; return b ; } inline poly Dvt ( poly a ) { int N = a . size () -1 ; for ( int i = 0 ; i < N ; ++ i ) a [ i ] = a [ i + 1 ] * ( i + 1 ); return a . resize ( N ), a ; } inline poly Itg ( poly a ) { int N = a . size () + 1 ; a . resize ( N ); for ( int i = N ; i >= 1 ; -- i ) a [ i ] = a [ i -1 ] / i ; return a [ 0 ] = 0 , a ; } inline poly Inv ( poly a ) { int K = a . size (), N = Sup ( K ); poly b , c , d ; a . resize ( N ), b . resize ( N ); b [ 0 ] = ONE / a [ 0 ]; for ( int len = 2 ; len <= N ; len <<= 1 ) { c . resize ( len ), d . resize ( len ); for ( int i = 0 ; i < len ; ++ i ) c [ i ] = a [ i ]; for ( int i = 0 ; i < ( len >> 1 ); ++ i ) d [ i ] = b [ i ]; NTT ( c , 1 ), NTT ( d , 1 ); for ( int i = 0 ; i < len ; ++ i ) c [ i ] = c [ i ] * d [ i ]; NTT ( c , -1 ); for ( int i = 1 ; i < ( len >> 1 ); ++ i ) c [ i ] = 0 ; c [ 0 ] = Mod -1 ; NTT ( c , 1 ); for ( int i = 0 ; i < len ; ++ i ) d [ i ] = d [ i ] * c [ i ]; NTT ( d , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) b [ i ] =- d [ i ]; } b . resize ( K ); return b ; } inline poly operator / ( poly a , poly b ) { int N = a . size (), M = b . size (); poly c = a , d = b ; c . reverse (), d . reverse (); d . resize ( N - M + 1 ), d = Inv ( d ); c = c * d ; c . resize ( N - M + 1 ), c . reverse (); return c ; } inline poly operator % ( poly a , poly b ) { int M = b . size (); poly q = a / b ; b = b * q ; poly r = a - b ; r . resize ( M -1 ); return r ; } inline pair < poly , poly > Div ( poly a , poly b ) { int M = b . size (); poly q = a / b ; b = b * q ; poly r = a - b ; r . resize ( M -1 ); return make_pair ( q , r ); } namespace DivideConquer { poly F [ 20 ][ 8 ], G [ 20 ][ 8 ]; inline void brute ( poly & a , poly & b , int l , int r , void work ( poly & a , poly & b , int i )) { work ( a , b , l ); for ( int i = l + 1 ; i <= r ; ++ i ) { for ( int j = l ; j < i ; ++ j ) a [ i ] += a [ j ] * b [ i - j ]; work ( a , b , i ); } } inline void Divide ( poly & a , poly & b , int l , int r , int dep , void work ( poly & a , poly & b , int i )) { if ( r - l + 1 <= 32 ) return brute ( a , b , l , r , work ); if ( l >= r ) return ; int coef = 1 << (( dep -1 ) * 3 ); poly tmp ; tmp . resize ( coef << 1 ); for ( int i = 0 ;; ++ i ) { int L = l + i * coef , R = min ( r , L + coef -1 ); if ( i ) { for ( int j = 0 ; j < ( coef << 1 ); ++ j ) tmp [ j ] = 0 ; for ( int j = 0 ; j < i ; ++ j ) for ( int k = 0 ; k < ( coef << 1 ); ++ k ) tmp [ k ] += F [ dep ][ j ][ k ] * G [ dep ][ i - j ][ k ]; NTT ( tmp , -1 ); for ( int j = L ; j <= R ; ++ j ) a [ j ] += tmp [ j - L + coef ]; } Divide ( a , b , L , R , dep -1 , work ); if ( R == r ) return ; for ( int j = 0 ; j < ( coef << 1 ); ++ j ) F [ dep ][ i ][ j ] = 0 ; for ( int j = L ; j <= R ; ++ j ) F [ dep ][ i ][ j - L ] = a [ j ]; NTT ( F [ dep ][ i ], 1 ); } } inline void solve ( poly & a , poly & b , int N , void work ( poly & a , poly & b , int i )) { if ( N <= 128 ) return brute ( a , b , 0 , N -1 , work ); int len = 1 , dep = 0 ; while ( len < N ) len <<= 3 , ++ dep ; len >>= 3 ; for ( int i = 1 ; i <= dep ; ++ i ) { int coef = 1 << (( i -1 ) * 3 ), mix = min (( N -1 ) / coef , 7l l ); for ( int j = 1 ; j <= mix ; ++ j ) { int L = ( j -1 ) * coef + 1 , R = min ( N -1 ,( j + 1 ) * coef -1 ); F [ i ][ j -1 ]. resize ( coef << 1 ), G [ i ][ j ]. resize ( coef << 1 ); for ( int k = 0 ; k < ( coef << 1 ); ++ k ) G [ i ][ j ][ k ] = 0 ; for ( int k = L ; k <= R ; ++ k ) G [ i ][ j ][ k - L + 1 ] = b [ k ]; NTT ( G [ i ][ j ], 1 ); } } Divide ( a , b , 0 , N -1 , dep , work ); } } using namespace DivideConquer ; inline void workln ( poly & a , poly & b , int i ) { if ( ! i ) a [ i ] = 0 ; else a [ i ] = i * b [ i ] - a [ i ]; } inline poly Ln ( poly a ) { int N = a . size (); poly b ; b . resize ( N ); solve ( b , a , N , workln ); b [ 0 ] = 0 ; for ( int i = 1 ; i < N ; ++ i ) b [ i ] *= ONE / i ; return b ; } inline void workexp ( poly & a , poly & b , int i ) { if ( ! i ) a [ i ] = 1 ; else a [ i ] *= ONE / i ; } inline poly Exp ( poly a ) { int N = a . size (); for ( int i = 0 ; i < N ; ++ i ) a [ i ] = a [ i ] * i ; poly b ; b . resize ( N ); solve ( b , a , N , workexp ); return b ; } inline void PrePow ( char * s , int & k1 , int & k2 , int & k3 ) { int len = strlen ( s + 1 ); for ( int i = 1 ; i <= len ; ++ i ) k1 = (( k1 * 10 ) + ( s [ i ] ^ 48 )) % Mod , k2 = (( k2 * 10 ) + ( s [ i ] ^ 48 )) % ( Mod -1 ); for ( int i = 1 ; i <= min ( 7l l , len ); ++ i ) k3 = ( k3 * 10 ) + ( s [ i ] ^ 48 ); } inline poly Pow ( poly a , ModInt < Mod > b ) { int N = a . size (); a = Exp ( Ln ( a ) * b ), a . resize ( N ); return a ; } inline poly Pow ( poly a , char * s ) { int N = a . size (), lst = N ; ModInt < Mod > k1 , k2 , k3 ; PrePow ( s , k1 . x , k2 . x , k3 . x ); poly b ; b . resize ( N ); if ( a [ 0 ] == 0 && k3 >= N ) return b ; for ( int i = 0 ; i < N ; ++ i ) if ( a [ i ] != 0 ) { lst = i ; break ;} if ( lst * k1 >= N ) return b ; ModInt < Mod > inv = ONE / a [ lst ], p = a [ lst ] ^ ( k2 . x ); for ( int i = 0 ; i < N - lst ; ++ i ) a [ i ] = a [ i + lst ] * inv ; for ( int i = N - lst ; i < N ; ++ i ) a [ i ] = 0 ; a = Ln ( a ); for ( int i = 0 ; i < N ; ++ i ) a [ i ] *= k1 ; a = Exp ( a ), lst = lst * k1 . x ; for ( int i = N -1 ; i >= lst ; -- i ) b [ i ] = a [ i - lst ] * p ; return b ; } inline poly Sqr ( poly a , int typ ) { int K = a . size (), N = Sup ( K ); poly f , g , h , tmp , res , ans ; f . resize ( N ), g . resize ( N ), h . resize ( N ), res . resize ( 1 ); f [ 0 ] = g [ 0 ] = Cipolla ( a [ 0 ]). first , h [ 0 ] = ONE / g [ 0 ]; for ( int len = 2 ; len <= N ; len <<= 1 ) { tmp . resize ( len ), ans . resize ( len ); for ( int i = 0 ; i < ( len >> 1 ); ++ i ) tmp [ i ] = h [ i ], res [ i ] = g [ i ] * g [ i ]; NTT ( res , -1 ); for ( int i = 0 ; i < ( len >> 1 ); ++ i ) ans [ i + ( len >> 1 )] = res [ i ] - a [ i ] - a [ i + ( len >> 1 )], ans [ i ] = 0 ; NTT ( ans , 1 ), NTT ( tmp , 1 ); for ( int i = 0 ; i < len ; ++ i ) ans [ i ] *= tmp [ i ] * ( ONE / 2 ); NTT ( ans , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) f [ i ] =- ans [ i ]; if ( len != N || typ == -1 ) { res . resize ( len ); for ( int i = 0 ; i < len ; ++ i ) res [ i ] = f [ i ]; NTT ( res , 1 ); for ( int i = 0 ; i < len ; ++ i ) g [ i ] = res [ i ], res [ i ] *= tmp [ i ]; NTT ( res , -1 ); res [ 0 ] = Mod -1 ; for ( int i = 1 ; i < ( len >> 1 ); ++ i ) res [ i ] = 0 ; NTT ( res , 1 ); for ( int i = 0 ; i < len ; ++ i ) res [ i ] *= tmp [ i ]; NTT ( res , -1 ); for ( int i = len >> 1 ; i < len ; ++ i ) h [ i ] =- res [ i ]; } } f . resize ( K ), h . resize ( K ); if ( typ == 1 ) return f ; else return h ; } inline poly sin ( poly a ) { ModInt < Mod > E = (( ModInt < Mod > ( 3 )) ^ (( Mod -1 ) >> 2 )); return ( Exp ( a * E ) - Exp ( a * ( - E ))) * (( E * 2 ) ^ ( Mod -2 )); } inline poly cos ( poly a ) { ModInt < Mod > E = (( ModInt < Mod > ( 3 )) ^ (( Mod -1 ) >> 2 )); return ( Exp ( a * E ) + Exp ( a * ( - E ))) * (( Mod + 1 ) >> 1 ); } inline poly tan ( poly a ) { int N = a . size (); a = sin ( a ) * Inv ( cos ( a )), a . resize ( N ); return a ; } inline poly arcsin ( poly a ) { int N = a . size (); poly b = a * a ; b . resize ( N ), b =- b , b [ 0 ] += 1 ; a = Itg ( Dvt ( a ) * Sqr ( b , -1 )); a . resize ( N ); return a ; } inline poly arctan ( poly a ) { int N = a . size (); poly b = a * a ; b . resize ( N ), b [ 0 ] += 1 ; a = Itg ( Dvt ( a ) * Inv ( b )); a . resize ( N ); return a ; } } using namespace Poly ;","title":"Poly"},{"location":"string/ACautomaton/","text":"\u8981\u5148\u8d4b\u503c \\(Sigma\\) \u4e3a\u5b57\u7b26\u96c6\u5927\u5c0f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace ACautomaton { int ch [ MAX ][ 30 ], d [ MAX ], fail [ MAX ], tot ; queue < int > q ; int Sigma ; inline int getid ( char c ) { if ( c >= 'a' && c <= 'z' ) return c - 'z' ; return c - 'A' + 26 ;} void insert ( char * s , int id ) { int now = 0 , len = strlen ( s + 1 ); for ( int i = 1 ; i <= len ; ++ i ) { int to = getid ( s [ i ]); if ( ! ch [ now ][ to ]) ch [ now ][ to ] =++ tot ; now = ch [ now ][ to ]; } d [ id ] = now ; } inline void build () { int now = 0 ; for ( int i = 0 ; i <= Sigma ; ++ i ) if ( ch [ now ][ i ]) q . emplace ( ch [ now ][ i ]); while ( ! q . empty ()) { now = q . front (); q . pop (); for ( int i = 0 ; i <= Sigma ; ++ i ) if ( ch [ now ][ i ]) fail [ ch [ now ][ i ]] = ch [ fail [ now ]][ i ], q . emplace ( ch [ now ][ i ]); else ch [ now ][ i ] = ch [ fail [ now ]][ i ]; } } }","title":"AC\u81ea\u52a8\u673a"},{"location":"string/FFTmatch/","text":"\u901a\u914d\u7b26\u5339\u914d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 namespace FFTmatch { static const double PI = acos ( -1 ); static const double eps = 0.5 ; struct Complex { double x , y ; Complex ( double X = 0.0 , double Y = 0.0 ) : x ( X ), y ( Y ) {} inline friend Complex operator + ( Complex a , Complex b ) { return Complex ( a . x + b . x , a . y + b . y );} inline friend Complex operator - ( Complex a , Complex b ) { return Complex ( a . x - b . x , a . y - b . y );} inline friend Complex operator * ( Complex a , Complex b ) { return Complex ( a . x * b . x - a . y * b . y , a . x * b . y + a . y * b . x );} template < typename T > inline friend Complex operator / ( Complex a , T b ) { return Complex ( a . x / b , a . y / b );} }; using VI = vector < int > ; using VC = vector < Complex > ; int rev [ MAX ], revnow ; inline int Sup ( int N ) { int K = 0 ; while (( 1 << K ) < N ) ++ K ; return K ;} inline void Rea ( int K ) { if ( K == revnow ) return ; rev [ 0 ] = 0 ; for ( int i = 1 ; i <= ( 1 << K ); ++ i ) rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | (( i & 1 ) << ( K -1 ));} inline void DFT ( VC & F , int K , int typ ) { int N = 1 << K ; for ( int i = 0 ; i < N ; ++ i ) if ( rev [ i ] > i ) Swp ( F [ i ], F [ rev [ i ]]); for ( int len = 2 , l = 1 ; len <= N ; len <<= 1 , l <<= 1 ) { Complex stp ( cos ( 2 * PI / len ), sin ( typ * 2 * PI / len )); for ( int st = 0 ; st < N ; st += len ) { Complex omega ( 1 , 0 ), U , V ; for ( int i = 0 ; i < l ; ++ i ) U = F [ st + i ], V = omega * F [ st + i + l ], F [ st + i ] = U + V , F [ st + i + l ] = U - V , omega = omega * stp ; } } if ( typ == -1 ) for ( int i = 0 ; i < N ; ++ i ) F [ i ] = F [ i ] / N ; } inline VI solve ( char * a , char * b ) { int n = strlen ( a ), m = strlen ( b ), N = n + m -1 ; int K = Sup ( N ); Rea ( K ); VI A , B , ans ; VC F , G , H ; F . resize ( 1 << K ), G . resize ( 1 << K ), H . resize ( 1 << K ); for ( int i = 0 ; i < n ; ++ i ) A . eb ( a [ i ] == '*' ? 0 : a [ i ] - 'a' + 1 ); for ( int i = 0 ; i < m ; ++ i ) B . eb ( b [ i ] == '*' ? 0 : b [ i ] - 'a' + 1 ); reverse ( A . begin (), A . end ()); for ( int i = n ; i < ( 1 << K ); ++ i ) A . eb ( 0 ); for ( int i = m ; i < ( 1 << K ); ++ i ) B . eb ( 0 ); for ( int i = 0 ; i < ( 1 << K ); ++ i ) F [ i ] = Complex ( A [ i ] * A [ i ] * A [ i ], 0 ), G [ i ] = Complex ( B [ i ], 0 ); DFT ( F , K , 1 ), DFT ( G , K , 1 ); for ( int i = 0 ; i < ( 1 << K ); ++ i ) H [ i ] = H [ i ] + F [ i ] * G [ i ]; for ( int i = 0 ; i < ( 1 << K ); ++ i ) F [ i ] = Complex ( A [ i ], 0 ), G [ i ] = Complex ( B [ i ] * B [ i ] * B [ i ], 0 ); DFT ( F , K , 1 ), DFT ( G , K , 1 ); for ( int i = 0 ; i < ( 1 << K ); ++ i ) H [ i ] = H [ i ] + F [ i ] * G [ i ]; for ( int i = 0 ; i < ( 1 << K ); ++ i ) F [ i ] = Complex ( A [ i ] * A [ i ], 0 ), G [ i ] = Complex ( B [ i ] * B [ i ], 0 ); DFT ( F , K , 1 ), DFT ( G , K , 1 ); for ( int i = 0 ; i < ( 1 << K ); ++ i ) H [ i ] = H [ i ] - F [ i ] * G [ i ] * Complex ( 2 , 0 ); DFT ( H , K , -1 ); for ( int i = n -1 ; i < m ; ++ i ) if ( fabs ( H [ i ]. x ) <= eps ) ans . eb ( i - n + 2 ); return ans ; } }","title":"FFT\u901a\u914d\u7b26\u5339\u914d"},{"location":"string/read/","text":"\u5b57\u7b26\u4e32\u5feb\u8bfb\uff0c\u9ed8\u8ba4\u662f\u8bfb\u5165\u5c0f\u5199\u548c\u5927\u5199\u5b57\u6bcd\uff0c ValidChar \u6839\u636e\u9700\u6c42\u4fee\u6539\u3002 1 2 3 4 5 6 7 8 9 10 11 12 namespace StringRead { bool ValidChar ( char c ) { return ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' );} inline int readstr ( char * str ) { char c = getchar (); int len = 0 ; while ( ! ValidChar ( c )) c = getchar (); while ( ValidChar ( c )) ++ len , * ( str + len ) = c , c = getchar (); * ( str + len + 1 ) = '\\0' ; return len ; } } using namespace StringRead ;","title":"\u5b57\u7b26\u4e32\u5feb\u8bfb"},{"location":"tree/Basic/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 namespace TreeBasic { int n ; vector < int > G [ MAX ]; int dep [ MAX ], dps ; void Diameter ( int now , int father ) { dep [ now ] = dep [ father ] + 1 ; if ( dep [ now ] > dep [ dps ]) dps = now ; for ( auto to : G [ now ]) if ( to != father ) Diameter ( to , now ); } inline int Diameter () { Diameter ( 1 , 0 ), Diameter ( dps , 0 ); return dep [ dps ];} int siz [ MAX ], wgt [ MAX ], ctr [ 2 ]; void Centroid ( int now , int father ) { siz [ now ] = 1 , wgt [ now ] = 0 ; for ( auto to : G [ now ]) if ( to != father ) Centroid ( to , now ), siz [ now ] += siz [ to ], cmax ( wgt [ now ], siz [ to ]); cmax ( wgt [ now ], n - wgt [ now ]); if ( wgt [ now ] <= n / 2 ) ctr [ ctr [ 0 ] != 0 ] = now ; } inline void Centroid () { Centroid ( 1 , 0 );} }","title":"\u6811\u57fa\u7840"},{"location":"tree/CUT/","text":"\u91cd\u94fe\u5256\u5206 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace HPD { int fa [ MAX ], siz [ MAX ], son [ MAX ], dep [ MAX ], dfn [ MAX ], rid [ MAX ], tot ; void dfs1 ( int now , int father , int depth ) { fa [ now ] = father , dep [ now ] = depth , siz [ now ] = 1 ; for ( auto to : G [ now ]) if ( to != father ) { dfs1 ( to , now , depth + 1 ); siz [ now ] += siz [ to ]; if ( siz [ to ] > siz [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( int now , int topf ) { top [ now ] = topf , dnf [ now ] =++ tot , rid [ tot ] = now ; if ( ! son [ now ]) return ; dfs2 ( son [ now ], topf ); for ( auto to : G [ now ]) if ( to != fa [ now ] && to != son [ now ]) dfs2 ( to , to ); } inline int LCA ( int a , int b ) { while ( top [ a ] != top [ b ]) { if ( dep [ top [ a ]] < dep [ top [ b ]]) swap ( a , b ); a = fa [ top [ a ]]; } return dep [ a ] < dep [ b ] ? a : b ; } }","title":"\u6811\u94fe\u5256\u5206"},{"location":"tree/CUT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace HPD { int fa [ MAX ], siz [ MAX ], son [ MAX ], dep [ MAX ], dfn [ MAX ], rid [ MAX ], tot ; void dfs1 ( int now , int father , int depth ) { fa [ now ] = father , dep [ now ] = depth , siz [ now ] = 1 ; for ( auto to : G [ now ]) if ( to != father ) { dfs1 ( to , now , depth + 1 ); siz [ now ] += siz [ to ]; if ( siz [ to ] > siz [ son [ now ]]) son [ now ] = to ; } } void dfs2 ( int now , int topf ) { top [ now ] = topf , dnf [ now ] =++ tot , rid [ tot ] = now ; if ( ! son [ now ]) return ; dfs2 ( son [ now ], topf ); for ( auto to : G [ now ]) if ( to != fa [ now ] && to != son [ now ]) dfs2 ( to , to ); } inline int LCA ( int a , int b ) { while ( top [ a ] != top [ b ]) { if ( dep [ top [ a ]] < dep [ top [ b ]]) swap ( a , b ); a = fa [ top [ a ]]; } return dep [ a ] < dep [ b ] ? a : b ; } }","title":"\u91cd\u94fe\u5256\u5206"},{"location":"tree/Prufer/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace Prufer { int n , fa [ MAX ], deg [ MAX ], p [ MAX ]; inline void MakePrufer () { for ( int i = 1 ; i <= n -1 ; ++ i ) ++ deg [ fa [ i ]]; for ( int i = 1 , j = 1 ; i <= n -2 ; ++ i , ++ j ) { while ( deg [ j ]) ++ j ; p [ i ] = fa [ j ]; while ( i <= n -2 &&!-- deg [ p [ i ]] && p [ i ] < j ) p [ i + 1 ] = fa [ p [ i ]], ++ i ; } } inline void TransPrufer () { for ( int i = 1 ; i <= n -2 ; ++ i ) ++ deg [ p [ i ]]; p [ n -1 ] = n ; for ( int i = 1 , j = 1 ; i <= n -1 ; ++ i , ++ j ) { while ( deg [ j ]) ++ j ; fa [ j ] = p [ i ]; while ( i <= n -2 &&!-- deg [ p [ i ]] && p [ i ] < j ) fa [ p [ i ]] = p [ i + 1 ], ++ i ; } } }","title":"Pr\u00fcfer\u5e8f\u5217"},{"location":"tree/multiplyLCA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace MultipLCA { vector < int > G [ MAX ]; int fa [ MAX ][ 20 ], dep [ MAX ]; void dfs ( int now , int father ) { dep [ now ] = dep [ father ] + 1 , fa [ now ][ 0 ] = father ; for ( int i = 1 ; i <= __lg ( dep [ now ]); ++ i ) fa [ now ][ i ] = fa [ fa [ now ][ i -1 ]][ i -1 ]; for ( auto to : G [ now ]) if ( to != father ) dfs ( to , now ); return ; } inline int LCA ( int x , int y ) { if ( dep [ x ] < dep [ y ]) Swp ( x , y ); while ( dep [ x ] > dep [ y ]) x = fa [ x ][ __lg ( dep [ x ] - dep [ y ])]; if ( x == y ) return x ; for ( int i = __lg ( dep [ x ]); ~ i ; -- i ) if ( fa [ x ][ i ] != fa [ y ][ i ]) x = fa [ x ][ i ], y = fa [ y ][ i ]; return fa [ x ][ 0 ]; } }","title":"\u500d\u589e\u6c42LCA"}]}