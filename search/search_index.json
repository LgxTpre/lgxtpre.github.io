{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 \u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Start"},{"location":"#home","text":"\u6b22\u8fce\u6765\u5230 \\(\\mathcal{LgxTpre}\\) \u7684\u4ee3\u7801\u4ed3\u5e93\uff01 \u8fd9\u91cc\u5b58\u653e\u4e86 \\(\\mathcal{LgxTpre}\\) \u7684\u5e38\u7528\u6a21\u677f\u3002","title":"Home"},{"location":"ATCF_default_source/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <bits/stdc++.h> #define int long long #define MAX 100010 #define INF 4557430888798830399 #define eb emplace_back #define fi first #define se second using namespace std ; int mod ; inline void Madd ( int & a , int b ){ a = a + b >= mod ? a + b - mod : a + b ;} inline void Mdel ( int & a , int b ){ a = a - b < 0 ? a - b + mod : a - b ;} inline void Mmul ( int & a , int b ){ a = a * b % mod ;} inline int Cadd ( int a , int b ){ return a + b >= mod ? a + b - mod : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + mod : a - b ;} inline int Cmul ( int a , int b ){ return a * b % mod ;} signed main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); return ( 0-0 ); }","title":"AT/CF\u7f3a\u7701\u6e90"},{"location":"default_source/","text":"\u73af\u5883\u914d\u7f6e\uff1a -lm -Wall -Wl,--stack=536870912 -O2 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include <bits/stdc++.h> #define ld long double #define ui unsigned int #define ull unsigned long long #define int long long #define eb emplace_back #define pb pop_back #define mp make_pair #define pii pair<int,int> #define fi first #define se second #define power(x) ((x)*(x)) #define gcd(x,y) __gcd(x,y) #define lg(x,y) __lg(x,y) using namespace std ; template < typename T = int > inline T read () { T s = 0 , w = 1 ; char c = getchar (); while ( ! isdigit ( c )) { if ( c == '-' ) w = -1 ; c = getchar ();} while ( isdigit ( c )) s = ( s << 1 ) + ( s << 3 ) + ( c ^ 48 ), c = getchar (); return s * w ; } template < typename T = int > inline void write ( T x , char ch ) { if ( x < 0 ) x =- x , putchar ( '-' ); static char stk [ 25 ]; int top = 0 ; do { stk [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( stk [ -- top ]); putchar ( ch ); return ; } namespace MyTool { static const int Mod = 998244353 ; template < typename T > inline void Swp ( T & a , T & b ) { T t = a ; a = b ; b = t ;} template < typename T > inline void cmax ( T & a , T b ) { a = a > b ? a : b ;} template < typename T > inline void cmin ( T & a , T b ) { a = a < b ? a : b ;} template < typename T > inline void Madd ( T & a , T b ) { a = a + b > Mod ? a + b - Mod : a + b ;} template < typename T > inline void Mdel ( T & a , T b ) { a = a - b < 0 ? a - b + Mod : a - b ;} template < typename T > inline void Mmul ( T & a , T b ) { a = a * b % Mod ;} template < typename T > inline void Mmod ( T & a ) { a = ( a % Mod + Mod ) % Mod ;} template < typename T > inline T Cadd ( T a , T b ) { return a + b >= Mod ? a + b - Mod : a + b ;} template < typename T > inline T Cdel ( T a , T b ) { return a - b < 0 ? a - b + Mod : a - b ;} template < typename T > inline T Cmul ( T a , T b ) { return a * b % Mod ;} template < typename T > inline T Cmod ( T a ) { return ( a % Mod + Mod ) % Mod ;} inline int qpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) Mmul ( res , a ); Mmul ( a , a ); b >>= 1 ;} return res ;} inline int qmul ( int a , int b ) { int res = 0 ; while ( b ) { if ( b & 1 ) Madd ( res , a ); Madd ( a , a ); b >>= 1 ;} return res ;} inline int Qpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a ); a = qmul ( a , a ); b >>= 1 ;} return res ;} } using namespace MyTool ; inline void file () { freopen ( \".in\" , \"r\" , stdin ); freopen ( \".out\" , \"w\" , stdout ); return ; } bool Mbe ; namespace LgxTpre { static const int MAX = 500010 ; static const int inf = 2147483647 ; static const int INF = 4557430888798830399 ; static const int mod = 1e9 + 7 ; static const int bas = 131 ; inline void lmy_forever () { } } bool Med ; signed main () { // file(); fprintf ( stderr , \"%.3lf MB \\n \" , abs ( & Med -& Mbe ) / 1048576.0 ); int Tbe = clock (); LgxTpre :: lmy_forever (); int Ted = clock (); cerr << 1e3 * ( Ted - Tbe ) / CLOCKS_PER_SEC << \" ms \\n \" ; return ( 0-0 ); }","title":"\u5e38\u7528\u7f3a\u7701\u6e90"},{"location":"ds/BST/","text":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } } \u6587\u827a\u5e73\u8861\u6811 FHQ_Treap\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( lson [ i ], rson [ i ]), tag [ lson [ i ]] ^= 1 , tag [ rson [ i ]] ^= 1 , tag [ i ] = 0 ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( lson [ siz [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); tag [ mid ] ^= 1 ; root = merge ( merge ( l , mid ), r ); } }","title":"\u5e73\u8861\u6811"},{"location":"ds/BST/#fhq_treap","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], sum [ MAX ], siz [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; sum [ i ] = sum [ lson [ i ]] + sum [ rson [ i ]] + val [ i ]; } inline int newnode ( int k ) { int now = top ? stk [ top -- ] :++ tot ; rnd [ now ] = randoom (), val [ now ] = sum [ now ] = k , siz [ now ] = 1 , lson [ now ] = rson [ now ] = 0 ; return now ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); if ( val [ now ] <= k ) l = now , split ( rson [ now ], k , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void ins ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); root = merge ( merge ( x , newnode ( k )), y ); } inline void del ( int k ) { int x = 0 , y = 0 , z = 0 ; split ( root , k , x , z ); split ( x , k -1 , x , y ); stk [ ++ top ] = y , y = merge ( lson [ y ], rson [ y ]); root = merge ( merge ( x , y ), z ); } inline int lis ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = siz [ x ] + 1 ; root = merge ( x , y ); return ans ; } int kthand ( int now , int k ) { if ( siz [ lson [ now ]] + 1 == k ) return val [ now ]; else if ( siz [ lson [ now ]] >= k ) return kthand ( lson [ now ], k ); else return kthand ( rson [ now ], k - siz [ lson [ now ]] -1 ); } inline int pre ( int k ) { int x = 0 , y = 0 ; split ( root , k -1 , x , y ); int ans = kthand ( x , siz [ x ]); root = merge ( x , y ); return ans ; } inline int suf ( int k ) { int x = 0 , y = 0 ; split ( root , k , x , y ); int ans = kthand ( y , 1 ); root = merge ( x , y ); return ans ; } }","title":"\u666e\u901a\u5e73\u8861\u6811 FHQ_Treap\uff1a"},{"location":"ds/BST/#fhq_treap_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 namespace FHQ_Treap { int lson [ MAX ], rson [ MAX ]; int rnd [ MAX ], val [ MAX ], siz [ MAX ], tag [ MAX ]; int root , tot ; int stk [ MAX ], top ; inline int randoom ( int l = 0 , int r = INF ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline void pushup ( int i ) { siz [ i ] = siz [ lson [ i ]] + siz [ rson [ i ]] + 1 ; } inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( lson [ i ], rson [ i ]), tag [ lson [ i ]] ^= 1 , tag [ rson [ i ]] ^= 1 , tag [ i ] = 0 ; } void split ( int now , int k , int & l , int & r ) { if ( ! now ) return l = r = 0 , void (); pushdown ( now ); if ( lson [ siz [ now ]] + 1 <= k ) l = now , split ( rson [ now ], k - siz [ lson [ now ]] -1 , rson [ now ], r ); else r = now , split ( lson [ now ], k , l , lson [ now ]); pushup ( now ); } int merge ( int l , int r ) { if ( ! l ||! r ) return l | r ; if ( rnd [ l ] < rnd [ r ]) return pushdown ( l ), rson [ l ] = merge ( rson [ l ], r ), pushup ( l ), l ; else return pushdown ( r ), lson [ r ] = merge ( l , lson [ r ]), pushup ( r ), r ; } inline void reverse ( int L , int R ) { int l = 0 , r = 0 , mid = 0 ; split ( root , R , l , r ); split ( l , L -1 , l , mid ); tag [ mid ] ^= 1 ; root = merge ( merge ( l , mid ), r ); } }","title":"\u6587\u827a\u5e73\u8861\u6811 FHQ_Treap\uff1a"},{"location":"ds/DSU/","text":"\u666e\u901a\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 namespace DSU { int N ; int fa [ MAX ], siz [ MAX ]; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} int find ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = find ( fa [ x ]);} inline void merge ( int x , int y ) { x = find ( y ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); siz [ x ] += siz [ y ], fa [ y ] = x ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} } \u53ef\u64a4\u9500\u5e76\u67e5\u96c6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace RDSU { int N ; int fa [ MAX ], siz [ MAX ]; struct dsu { int x , fx , siz ; dsu ( int X = 0 , int Fx = 0 , int Siz = 0 ) { x = X , fx = Fx , siz = Siz ;} } stk [ MAX ]; int top ; inline void init () { for ( int i = 1 ; i <= N ; ++ i ) fa [ i ] = i , siz [ i ] = 1 ;} inline int find ( int x ) { while ( x != fa [ x ]) x = fa [ x ]; return x ;} inline void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( siz [ x ] < siz [ y ]) Swp ( x , y ); stk [ ++ top ] = dsu ( x , fa [ x ], siz [ x ]), stk [ ++ top ] = dsu ( y , fa [ y ], siz [ y ]); siz [ x ] += siz [ y ], fa [ y ] = x ; } inline void back ( int last ) { while ( top > last ) fa [ stk [ top ]. x ] = stk [ top ]. fx , siz [ stk [ top ]. x ] = stk [ top ]. siz , -- top ;} inline bool check ( int x , int y ) { return find ( x ) == find ( y );} }","title":"\u5e76\u67e5\u96c6"},{"location":"ds/LCT/","text":"\u901a\u7528\u6a21\u677f\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"LCT"},{"location":"ds/LCT/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 namespace Link_Cat_Tree { int fa [ MAX ], ch [ MAX ][ 2 ], tag [ MAX ], siz [ MAX ], val [ MAX ]; inline bool get ( int i ) { return ch [ fa [ i ]][ 1 ] == i ;} inline bool noroot ( int i ) { return ch [ fa [ i ]][ get ( i )] == i ;} inline void pushup ( int i ) { siz [ i ] = siz [ ch [ i ][ 0 ]] + siz [ ch [ i ][ 1 ]] + 1 ;} inline void pushdown ( int i ) { if ( tag [ i ]) Swp ( ch [ i ][ 0 ], ch [ i ][ 1 ]), tag [ ch [ i ][ 0 ]] ^= 1 , tag [ ch [ i ][ 1 ]] ^= 1 , tag [ i ] = 0 ;} inline void pushall ( int i ) { if ( noroot ( i )) pushall ( fa [ i ]); pushdown ( i );} inline void rotate ( int x ) { int y = fa [ x ], z = fa [ y ]; bool k1 = get ( x ), k2 = get ( y ); if ( noroot ( y )) ch [ z ][ k2 ] = x ; fa [ x ] = z ; ch [ y ][ k1 ] = ch [ x ][ ! k1 ], fa [ ch [ x ][ ! k1 ]] = y ; ch [ x ][ ! k1 ] = y , fa [ y ] = x ; pushup ( y ), pushup ( x ); } inline void splay ( int x ) { pushall ( x ); while ( noroot ( x )) { int y = fa [ x ], z = fa [ y ]; if ( noroot ( y )) ( get ( x ) ^ get ( y )) ? rotate ( x ) : rotate ( y ); rotate ( x ); } } inline void access ( int x ) { for ( int y = 0 ; x ; y = x , x = fa [ x ]) splay ( x ), ch [ x ][ 1 ] = y , pushup ( x );} inline void makeroot ( int x ) { access ( x ), splay ( x ), tag [ x ] ^= 1 ;} inline int findroot ( int x ) { access ( x ), splay ( x ); while ( ch [ x ][ 0 ]) pushdown ( x ), x = ch [ x ][ 0 ]; return splay ( x ), x ;} inline void split ( int x , int y ) { makeroot ( x ), access ( y ), splay ( y );} inline void link ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) != x ) fa [ x ] = y ;} inline void cut ( int x , int y ) { makeroot ( x ); if ( findroot ( y ) == x && fa [ y ] == x &&! ch [ y ][ 0 ]) fa [ y ] = ch [ x ][ 1 ] = 0 , pushup ( x );} inline bool check ( int x , int y ) { return findroot ( x ) == findroot ( y );} }","title":"\u901a\u7528\u6a21\u677f\uff1a"},{"location":"graph/MST/","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"graph/flow/","text":"\u6700\u5927\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } } \u8d39\u7528\u6d41\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u7f51\u7edc\u6d41"},{"location":"graph/flow/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 namespace MaxFlow { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val = 0 ; return ; } int s , t ; int maxflow , d [ MAX ], pre [ MAX ]; queue < int > q ; inline bool Layer () { memset ( d , 0 , sizeof d ); while ( ! q . empty ()) q . pop (); d [ s ] = 1 , pre [ s ] = head [ s ], q . push ( s ); while ( ! q . empty ()) { int now = q . front (); q . pop (); for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; if ( ! d [ to ] && val ) { d [ to ] = d [ now ] + 1 , pre [ to ] = head [ to ], q . push ( to ); if ( to == t ) return 1 ; } } } return 0 ; } int Dinic ( int now , int flow ) { if ( now == t ) return flow ; int rest = flow ; for ( int i = pre [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val ; pre [ now ] = i ; if ( d [ to ] == d [ now ] + 1 && val ) { int k = Dinic ( to , min ( val , rest )); if ( ! k ) d [ to ] = 0 ; e [ i ]. val -= k , e [ i ^ 1 ]. val += k , rest -= k ; if ( ! rest ) break ; } } return flow - rest ; } inline void solve () { while ( Layer ()) maxflow += Dinic ( s , INF ); return ; } }","title":"\u6700\u5927\u6d41\uff1a"},{"location":"graph/flow/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace MaxFlowMinCost { struct edge { int nex , to , val , flow ;} e [ MAX << 1 ]; int head [ MAX ], cnt = 1 ; inline void add ( int x , int y , int val , int flow ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = val , e [ cnt ]. flow = flow ; e [ ++ cnt ]. nex = head [ y ], head [ y ] = cnt , e [ cnt ]. to = x , e [ cnt ]. val =- val , e [ cnt ]. flow = 0 ; return ; } int s , t ; int maxflow , mincost ; int dis [ MAX ], vis [ MAX ], pre [ MAX ], incf [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ); q . push ( s ), vis [ s ] = 1 , dis [ s ] = 0 , incf [ s ] = INF ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to , val = e [ i ]. val , flow = e [ i ]. flow ; if ( ! flow ) continue ; if ( dis [ to ] > dis [ now ] + val ) { dis [ to ] = dis [ now ] + val , incf [ to ] = min ( incf [ now ], flow ), pre [ to ] = i ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return dis [ t ] != INF ; } inline void Augment () { int now = t ; maxflow += incf [ t ], mincost += incf [ t ] * dis [ t ]; while ( now != s ) { int i = pre [ now ]; e [ i ]. flow -= incf [ t ], e [ i ^ 1 ]. flow += incf [ t ], now = e [ i ^ 1 ]. to ; } } inline void solve () { while ( SPFA ()) Augment (); } }","title":"\u8d39\u7528\u6d41\uff1a"},{"location":"graph/shortpath/","text":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } } SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } } SPFA \u5224\u8d1f\u73af\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } } Johnson\u5168\u6e90\u6700\u77ed\u8def\uff1a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"\u6700\u77ed\u8def\u76f8\u5173"},{"location":"graph/shortpath/#dijktra","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 namespace dijkstra { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; priority_queue < pii > q ; inline void dijkstra () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); dis [ s ] = 0 , q . push ( mp ( 0 , s )); while ( ! q . empty ()) { int now = q . top (). second ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) dis [ to ] = dis [ now ] + e [ i ]. val , q . push ( mp ( - dis [ to ], to )); } } return ; } }","title":"dijktra \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace SPFA { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ]; queue < int > q ; inline void SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return ; } }","title":"SPFA \u5355\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/shortpath/#spfa_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Check_Loop { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; inline bool SPFA () { memset ( dis , 0x3f , sizeof dis ), memset ( vis , 0 , sizeof vis ), memset ( con , 0 , sizeof con ); q . push ( s ), dis [ s ] = 0 , vis [ s ] = 1 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val , con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } }","title":"SPFA \u5224\u8d1f\u73af\uff1a"},{"location":"graph/shortpath/#johnson","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 namespace Johnson { struct edge { int nex , to , val ;} e [ MAX << 1 ]; int head [ MAX ], cnt ; inline void add ( int x , int y , int z ) { e [ ++ cnt ]. nex = head [ x ], head [ x ] = cnt , e [ cnt ]. to = y , e [ cnt ]. val = z ; return ; } int ans [ MAX ][ MAX ]; int dis [ MAX ], vis [ MAX ], con [ MAX ]; queue < int > q ; int Dis [ MAX ], Vis [ MAX ]; priority_queue < pii > Q ; inline bool SPFA ( int st ) { while ( ! q . empty ()) q . pop (); memset ( vis , 0 , sizeof vis ), memset ( dis , 0x3f , sizeof dis ), memset ( con , 0 , sizeof con ); q . push ( st ), vis [ st ] = 1 , dis [ st ] = 0 ; while ( ! q . empty ()) { int now = q . front (); q . pop (); vis [ now ] = 0 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( dis [ to ] > dis [ now ] + e [ i ]. val ) { dis [ to ] = dis [ now ] + e [ i ]. val ; con [ to ] = con [ now ] + 1 ; if ( con [ now ] >= n ) return 1 ; if ( ! vis [ to ]) vis [ to ] = 1 , q . push ( to ); } } } return 0 ; } inline void dijkstra ( int st ) { memset ( Vis , 0 , sizeof Vis ), memset ( Dis , 0x3f , sizeof Dis ); Q . push ( mp ( 0 , st )), Dis [ st ] = 0 ; while ( ! Q . empty ()) { int now = Q . top (). second ; Q . pop (); if ( Vis [ now ]) continue ; Vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = e [ i ]. nex ) { int to = e [ i ]. to ; if ( Dis [ to ] > Dis [ now ] + e [ i ]. val ) Dis [ to ] = Dis [ now ] + e [ i ]. val , Q . push ( mp ( - Dis [ to ], to )); } } return ; } inline bool solve () { for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ); if ( SPFA ( 0 )) return 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = head [ i ]; j ; j = e [ j ]. nex ) e [ j ]. val += dis [ i ] - dis [ e [ j ]. to ]; for ( int i = 1 ; i <= n ; ++ i ) { dijkstra ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( Dis [ j ] == INF ) ans [ i ][ j ] = -1 ; else ans [ i ][ j ] = Dis [ j ] + dis [ j ] - dis [ i ]; } return 0 ; } }","title":"Johnson\u5168\u6e90\u6700\u77ed\u8def\uff1a"},{"location":"graph/tarjan/","text":"","title":"tarjan"},{"location":"math/Pollard_Rho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 namespace Prime_Check { int mix , seed , step ; static const int P [] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 }; static const int Pcnt = 12 ; inline int qmul ( int a , int b , int mod ) { int ans = a * b - ( int )(( long double ) a * b / mod + 0.5 ) * mod ; return ans < 0 ? ans + mod : ans ;} inline int qpow ( int a , int b , int mod ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = qmul ( res , a , mod ); a = qmul ( a , a , mod ); b >>= 1 ;} return res ;} inline int f ( int x , int mod ) { return ( qmul ( x , x , mod ) + seed ) % mod ;} inline int randoom ( int l , int r ) { static mt19937_64 sd ( 20070707 ); static uniform_int_distribution < int > range ( l , r ); return range ( sd ); } inline bool Miller_Robin ( int x ) { if ( x <= 2 ) return x == 2 ; int y_ = x -1 ; while ( ! ( y_ & 1 )) y_ >>= 1 ; for ( int i = 0 ; i < Pcnt ; ++ i ) { if ( x == P [ i ]) return 1 ; int flag = 0 , y = y_ , z = qpow ( P [ i ], y , x ); if ( z == 1 ) flag = 1 ; else while ( y < x -1 ) { if ( z == x -1 ) { flag = 1 ; break ;} y <<= 1 , z = qmul ( z , z , x ); } if ( ! flag ) return 0 ; } return 1 ; } inline int floyd ( int x ) { seed = randoom ( 0 , x -1 ); int fast , slow , res = 1 ; fast = slow = randoom ( 0 , x -1 ); fast = f ( fast , x ); for ( int i = 0 ; slow != fast ; ++ i ) { res = qmul ( res ,( fast - slow ) % x + x , x ); if ( ! res ) res = ( fast - slow ) % x + x ; if ( i % step == 0 ) { int g = gcd ( res , x ); if ( g != 1 ) return g ; res = 1 ;} slow = f ( slow , x ), fast = f ( f ( fast , x ), x ); } return gcd ( res , x ); } inline void Pollard_Rho ( int x ) { if ( x == 1 ) return ; if ( Miller_Robin ( x )) return cmax ( mix , x ); int k = 1 ; step = (( int ) log ( x )) << 1 | 1 ; while ( k == 1 ) k = floyd ( x ); Pollard_Rho ( k ), Pollard_Rho ( x / k ); } inline int solve ( int n ) { mix = 0 ; Pollard_Rho ( n ); if ( mix == n ) return -1 ; else return mix ; } }","title":"Pollard_Rho"},{"location":"math/Sieve/","text":"\u7ebf\u6027\u7b5b\u7d20\u6570\u3002 \u7b5b\u6cd5\u6c42\u6b27\u62c9\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570\uff1a \\(d_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u4e2a\u6570\uff0c \\(num_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u51fa\u73b0\u6b21\u6570\u3002 \u7b5b\u6cd5\u6c42\u7ea6\u6570\u548c\uff1a \\(f_i\\) \u8868\u793a \\(i\\) \u7684\u7ea6\u6570\u548c\uff0c \\(g_i\\) \u8868\u793a \\(i\\) \u7684\u6700\u5c0f\u8d28\u56e0\u5b50\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 namespace Sieve { static const int N = 100000 ; static const int MAX = 10010 ; int vis [ N + 10 ], P [ MAX ], Pcnt ; inline void Linear_Sieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( ! i % P [ j ]) break ; } } return ; } int phi [ N + 10 ]; inline void Phi_Sieve () { phi [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , phi [ i ] = i -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) phi [ i * P [ j ]] = phi [ i ] * phi [ P [ j ]]; else { phi [ i * P [ j ]] = phi [ i ] * P [ j ]; break ;} } } return ; } int mu [ N + 10 ]; inline void Mu_Sieve () { mu [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , mu [ i ] = -1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) mu [ i * P [ j ]] =- mu [ i ]; else { mu [ i * P [ j ]] = 0 ; break ;} } } return ; } int d [ N + 10 ], num [ N + 10 ]; inline void D_Sieve () { d [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , d [ i ] = 2 , num [ i ] = 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) num [ i * P [ j ]] = 1 , d [ i * P [ j ]] = d [ i ] * 2 ; else { num [ i * P [ j ]] = num [ i ] + 1 , d [ i * P [ j ]] = d [ i ] / num [ i * P [ j ]] * ( num [ i * P [ j ]] + 1 ); break ;} } } return ; } int f [ N + 10 ], g [ N + 10 ]; inline void Sum_Sieve () { f [ 1 ] = g [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! vis [ i ]) P [ ++ Pcnt ] = i , f [ i ] = g [ i ] = i + 1 ; for ( int j = 1 ; j <= Pcnt && i * P [ j ] <= N ; ++ j ) { vis [ i * P [ j ]] = 1 ; if ( i % P [ j ]) f [ i * P [ j ]] = f [ i ] * f [ P [ j ]], g [ i * P [ j ]] = P [ j ] + 1 ; else { f [ i * P [ j ]] = f [ i ] / g [ i ] * ( g [ i ] * P [ j ] + 1 ), g [ i * P [ j ]] = g [ i ] * P [ j ] + 1 ; break ;} } } return ; } }","title":"\u7b5b\u6cd5"}]}